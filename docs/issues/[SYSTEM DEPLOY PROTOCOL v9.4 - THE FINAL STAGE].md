  
[SYSTEM: DEPLOY PROTOCOL v9.4 - THE FINAL STAGE]  
To: Claude (Lead Engineer)  
From: Gemini (Architect)  
Via: User (Bridge)  
Context:  
We are establishing the "Golden Standard" for our DevOps workflow.  
Previous iterations had issues with column name mismatches and empty ticket bodies.  
Objective: Deploy the final version of the JIT Issue Creator. It must inspect the database, map columns dynamically, handle data types correctly (Status vs Select), and inject a standardized Markdown body into every new ticket.  
Action Required:  
Overwrite scripts/quick_create_issue.py with this production-ready implementation.  
ğŸ› ï¸ The Production JIT Issue Creator (scripts/quick_create_issue.py)  
import os  
import sys  
import requests  
import argparse  
import json  
from dotenv import load_dotenv  
  
# --- CONFIGURATION ---  
load_dotenv()  
NOTION_TOKEN = os.getenv("NOTION_TOKEN")  
DATABASE_ID = os.getenv("NOTION_DB_ID")  
HEADERS = {  
    "Authorization": f"Bearer {NOTION_TOKEN}",  
    "Content-Type": "application/json",  
    "Notion-Version": "2022-06-28"  
}  
  
# --- STANDARD TEMPLATE BODY (Blocks) ---  
# This ensures every ticket starts with the correct structure  
TEMPLATE_BLOCKS = [  
    {  
        "object": "block",  
        "type": "callout",  
        "callout": {  
            "rich_text": [{"type": "text", "text": {"content": "ğŸ¤– Generated by DevOps Automation"}}],  
            "icon": {"emoji": "ğŸ—ï¸"},  
            "color": "gray_background"  
        }  
    },  
    {  
        "object": "block",  
        "type": "heading_2",  
        "heading_2": {"rich_text": [{"type": "text", "text": {"content": "ğŸ¯ Objective"}}]}  
    },  
    {  
        "object": "block",  
        "type": "paragraph",  
        "paragraph": {"rich_text": [{"type": "text", "text": {"content": "Describe the core implementation goal here."}}]}  
    },  
    {  
        "object": "block",  
        "type": "heading_2",  
        "heading_2": {"rich_text": [{"type": "text", "text": {"content": "ğŸ›¡ï¸ Risk Control (Quant Safety)"}}]}  
    },  
    {  
        "object": "block",  
        "type": "to_do",  
        "to_do": {"rich_text": [{"type": "text", "text": {"content": "Idempotency Check (Request ID)"}}], "checked": False}  
    },  
    {  
        "object": "block",  
        "type": "to_do",  
        "to_do": {"rich_text": [{"type": "text", "text": {"content": "Volume Limits Validation"}}], "checked": False}  
    },  
    {  
        "object": "block",  
        "type": "heading_2",  
        "heading_2": {"rich_text": [{"type": "text", "text": {"content": "âœ… Definition of Done (DoD)"}}]}  
    },  
    {  
        "object": "block",  
        "type": "to_do",  
        "to_do": {"rich_text": [{"type": "text", "text": {"content": "Code Implemented"}}], "checked": False}  
    },  
    {  
        "object": "block",  
        "type": "to_do",  
        "to_do": {"rich_text": [{"type": "text", "text": {"content": "Unit/Integration Tests Passed"}}], "checked": False}  
    }  
]  
  
def get_db_schema():  
    """Dynamically map logical fields to physical Notion columns."""  
    url = f"https://api.notion.com/v1/databases/{DATABASE_ID}"  
    try:  
        resp = requests.get(url, headers=HEADERS)  
        if resp.status_code != 200:  
            print(f"âŒ DB Error: {resp.status_code} - {resp.text}")  
            sys.exit(1)  
              
        props = resp.json().get("properties", {})  
        schema = {"title": None, "status": None, "priority": None, "tags": None}  
        schema_types = {} # Store types to format payload correctly  
  
        print("ğŸ” Scanning Database Schema...")  
        for name, prop in props.items():  
            ptype = prop["type"]  
            name_lower = name.lower()  
              
            # Map Title  
            if ptype == "title":  
                schema["title"] = name  
                schema_types["title"] = ptype  
              
            # Map Status (Handle 'status' type vs 'select' type)  
            elif name_lower in ["status", "çŠ¶æ€", "state"] and ptype in ["status", "select"]:  
                schema["status"] = name  
                schema_types["status"] = ptype  
                  
            # Map Priority  
            elif any(k in name_lower for k in ["prio", "level", "ä¼˜å…ˆçº§"]) and ptype == "select":  
                schema["priority"] = name  
                schema_types["priority"] = ptype  
                  
            # Map Tags  
            elif any(k in name_lower for k in ["tag", "label", "category", "æ ‡ç­¾"]) and ptype == "multi_select":  
                schema["tags"] = name  
                schema_types["tags"] = ptype  
  
        if not schema["title"]:  
            print("âŒ Critical: No Title column found!")  
            sys.exit(1)  
              
        return schema, schema_types  
    except Exception as e:  
        print(f"âŒ Schema detection failed: {e}")  
        sys.exit(1)  
  
def create_issue(title, priority, tags):  
    # 1. Get Schema  
    schema, types = get_db_schema()  
    print(f"   -> Mapping: Title='{schema['title']}' | Status='{schema['status']}' ({types.get('status')})")  
  
    # 2. Check Duplicates  
    query_url = f"https://api.notion.com/v1/databases/{DATABASE_ID}/query"  
    payload = {"filter": {"property": schema["title"], "rich_text": {"equals": title}}}  
    try:  
        check = requests.post(query_url, headers=HEADERS, json=payload)  
        if check.status_code == 200 and check.json()["results"]:  
            print(f"âš ï¸ Issue exists: {title}")  
            print(f"ğŸ”— URL: {check.json()['results'][0]['url']}")  
            return  
    except: pass  
  
    # 3. Build Properties Payload  
    props = {}  
    props[schema["title"]] = {"title": [{"text": {"content": title}}]}  
      
    # Priority  
    if schema["priority"]:  
        props[schema["priority"]] = {"select": {"name": priority}}  
      
    # Status (Handle Type Difference)  
    if schema["status"]:  
        st_type = types["status"]  
        # 'status' property uses {"status": {"name": "..."}}  
        # 'select' property uses {"select": {"name": "..."}}  
        props[schema["status"]] = {st_type: {"name": "In Progress"}}  
      
    # Tags  
    if schema["tags"]:  
        props[schema["tags"]] = {"multi_select": [{"name": t.strip()} for t in tags]}  
  
    # 4. Create Issue with Content  
    create_url = "https://api.notion.com/v1/pages"  
    data = {  
        "parent": {"database_id": DATABASE_ID},  
        "properties": props,  
        "children": TEMPLATE_BLOCKS  
    }  
      
    try:  
        resp = requests.post(create_url, headers=HEADERS, json=data)  
        if resp.status_code == 200:  
            print(f"âœ… SUCCESS: Issue Created with Template!")  
            print(f"ğŸ”— URL: {resp.json()['url']}")  
        else:  
            print(f"âŒ Creation Failed: {resp.status_code}")  
            print(resp.text)  
    except Exception as e:  
        print(f"âŒ Network Error: {e}")  
  
if __name__ == "__main__":  
    parser = argparse.ArgumentParser()  
    parser.add_argument("title", help="Issue Title")  
    parser.add_argument("--prio", default="P1", help="Priority")  
    parser.add_argument("--tags", default="Dev", help="Tags")  
    args = parser.parse_args()  
      
    if not NOTION_TOKEN or not DATABASE_ID:  
        print("âŒ .env configuration missing")  
        sys.exit(1)  
          
    create_issue(args.title, args.prio, args.tags.split(","))  
  
ğŸ”„ Update CLAUDE_START.txt (Rule Update)  
Update the rule file to reflect that we now auto-inject templates.  
**[SYSTEM: ACTIVATE PROTOCOL v9.4]**  
  
**Role**: You are the **Lead Python Engineer (Builder)** for the MT5-CRS Project.  
**Architect**: Gemini Pro (Auditor & Planner).  
**Bridge**: User (Executor).  
  
**ğŸ“œ AI_RULES (Strict Compliance Required):**  
0.  **Ticket First**: Before coding, run:  
    `python3 scripts/quick_create_issue.py "#0xx.x Title" --prio P0 --tags Tag1`  
    *This will auto-create the ticket AND inject the Requirement Template.*  
      
1.  **Risk is Syntax**: NEVER use hardcoded volumes. ALWAYS import `KellySizer` or `LiveRiskGuard`.  
2.  **Context Aware**: Do not hallucinate file paths. Use the project structure provided.  
3.  **Async First**: All IO (ZMQ, API) must be asynchronous (`asyncio`).  
4.  **No Fluff**: Output code and terminal commands directly.  
5.  **Idempotency**: All transaction logic must use unique request IDs.  
  
**Current Phase**: #012 Live Implementation  
---  
**[TASK STARTS HERE]**  
  
ğŸŒ‰ ä½ çš„æ‰§è¡Œä¸éªŒæ”¶æ­¥éª¤  
 * Downlink: å°†ä¸Šé¢çš„ä»£ç åŒ…å‘ç»™ Claudeã€‚  
 * Verify (å…³é”®): å¾… Claude å®Œæˆåï¼Œè¯·ç«‹å³è¿è¡Œä¸€æ¬¡çœŸå®å»ºå•å‘½ä»¤ï¼Œä¸ºæˆ‘ä»¬ä¸‹ä¸€æ­¥çš„å¼€å‘é“ºè·¯ï¼š  
   python3 scripts/quick_create_issue.py "#012.2 [Core] Order Executor & Idempotency" --prio P0 --tags Core,Trade  
  
  
