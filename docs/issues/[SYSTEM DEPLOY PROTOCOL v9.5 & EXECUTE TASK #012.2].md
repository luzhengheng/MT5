  
[SYSTEM: DEPLOY PROTOCOL v9.5 & EXECUTE TASK #012.2]  
To: Claude (Lead Engineer)  
From: Gemini (Architect)  
Via: User (Bridge)  
Context:  
 * Infrastructure: We identified a fragility in the previous issue creator script regarding localized Notion Status names (e.g., "ËøõË°å‰∏≠" vs "In Progress"). We are upgrading to Protocol v9.5.  
 * Task: With the infrastructure secured, we proceed to implement the Core Order Executor (#012.2).  
Objective:  
 * Deploy the Polyglot JIT Issue Creator (Schema-Aware).  
 * Implement the MT5 Order Executor (Idempotency Engine).  
Action Required:  
Create/Overwrite the following 2 files.  
1. scripts/quick_create_issue.py (v9.5 - Universal Compatibility)  
This version dynamically inspects valid status options from the DB Schema to prevent 400 Errors.  
import os  
import sys  
import requests  
import argparse  
import json  
from dotenv import load_dotenv  
  
# --- CONFIGURATION ---  
load_dotenv()  
NOTION_TOKEN = os.getenv("NOTION_TOKEN")  
DATABASE_ID = os.getenv("NOTION_DB_ID")  
HEADERS = {  
    "Authorization": f"Bearer {NOTION_TOKEN}",  
    "Content-Type": "application/json",  
    "Notion-Version": "2022-06-28"  
}  
  
# --- TEMPLATE ---  
TEMPLATE_BLOCKS = [  
    {  
        "object": "block",  
        "type": "callout",  
        "callout": {  
            "rich_text": [{"type": "text", "text": {"content": "ü§ñ Generated by DevOps Automation"}}],  
            "icon": {"emoji": "üèóÔ∏è"},  
            "color": "gray_background"  
        }  
    },  
    {  
        "object": "block",  
        "type": "heading_2",  
        "heading_2": {"rich_text": [{"type": "text", "text": {"content": "üéØ Objective"}}]}  
    },  
    {  
        "object": "block",  
        "type": "paragraph",  
        "paragraph": {"rich_text": [{"type": "text", "text": {"content": "Describe implementation goal."}}]}  
    },  
    {  
        "object": "block",  
        "type": "heading_2",  
        "heading_2": {"rich_text": [{"type": "text", "text": {"content": "üõ°Ô∏è Risk Control"}}]}  
    },  
    {  
        "object": "block",  
        "type": "to_do",  
        "to_do": {"rich_text": [{"type": "text", "text": {"content": "Idempotency Check"}}], "checked": False}  
    },  
    {  
        "object": "block",  
        "type": "heading_2",  
        "heading_2": {"rich_text": [{"type": "text", "text": {"content": "‚úÖ Definition of Done"}}]}  
    },  
    {  
        "object": "block",  
        "type": "to_do",  
        "to_do": {"rich_text": [{"type": "text", "text": {"content": "Tests Passed"}}], "checked": False}  
    }  
]  
  
def get_smart_schema():  
    """  
    Introspect DB to find valid column names and status options.  
    """  
    url = f"https://api.notion.com/v1/databases/{DATABASE_ID}"  
    try:  
        resp = requests.get(url, headers=HEADERS)  
        if resp.status_code != 200:  
            print(f"‚ùå DB Access Error: {resp.status_code}")  
            sys.exit(1)  
              
        props = resp.json().get("properties", {})  
        schema = {"title": None, "status": None, "status_type": None, "valid_status": None, "priority": None, "tags": None}  
          
        print("üîç Analyzing Database Schema...")  
        for name, prop in props.items():  
            ptype = prop["type"]  
            name_lower = name.lower()  
              
            # 1. Title  
            if ptype == "title":  
                schema["title"] = name  
              
            # 2. Status (Smart Detection)  
            elif name_lower in ["status", "Áä∂ÊÄÅ", "state"] and ptype in ["status", "select"]:  
                schema["status"] = name  
                schema["status_type"] = ptype  
                  
                # Find a valid "In Progress" option  
                options = []  
                if ptype == "status":  
                    options = prop.get("status", {}).get("options", [])  
                elif ptype == "select":  
                    options = prop.get("select", {}).get("options", [])  
                  
                # Logic: Find 'In Progress', 'ËøõË°å‰∏≠', or blue color, or just take the 2nd option  
                for opt in options:  
                    opt_name = opt["name"]  
                    if opt_name in ["In Progress", "In progress", "ËøõË°å‰∏≠", "Â§ÑÁêÜ‰∏≠", "Doing"]:  
                        schema["valid_status"] = opt_name  
                        break  
                  
                # Fallback: If no exact match, try to pick the first "In progress" group if available (for status type)  
                # Or just pick the second item in list (usually ToDo -> InProgress -> Done)  
                if not schema["valid_status"] and len(options) >= 2:  
                     schema["valid_status"] = options[1]["name"]  
  
            # 3. Priority & Tags  
            elif "prio" in name_lower or "‰ºòÂÖàÁ∫ß" in name_lower: schema["priority"] = name  
            elif "tag" in name_lower or "Ê†áÁ≠æ" in name_lower: schema["tags"] = name  
  
        return schema  
    except Exception as e:  
        print(f"‚ùå Schema Error: {e}")  
        sys.exit(1)  
  
def create_issue(title, priority, tags):  
    s = get_smart_schema()  
    print(f"   -> Schema: Title='{s['title']}' | Status='{s['status']}' (Target: {s['valid_status']})")  
  
    # Check Duplicates  
    q_url = f"https://api.notion.com/v1/databases/{DATABASE_ID}/query"  
    try:  
        check = requests.post(q_url, headers=HEADERS, json={"filter": {"property": s["title"], "rich_text": {"equals": title}}})  
        if check.status_code == 200 and check.json()["results"]:  
            print(f"‚ö†Ô∏è Issue exists: {title}")  
            return  
    except: pass  
  
    # Build Properties  
    props = {}  
    props[s["title"]] = {"title": [{"text": {"content": title}}]}  
      
    if s["priority"]:  
        props[s["priority"]] = {"select": {"name": priority}}  
          
    if s["status"] and s["valid_status"]:  
        key = "status" if s["status_type"] == "status" else "select"  
        props[s["status"]] = {key: {"name": s["valid_status"]}}  
  
    if s["tags"]:  
        props[s["tags"]] = {"multi_select": [{"name": t.strip()} for t in tags]}  
  
    # Create  
    resp = requests.post("https://api.notion.com/v1/pages", headers=HEADERS, json={  
        "parent": {"database_id": DATABASE_ID},  
        "properties": props,  
        "children": TEMPLATE_BLOCKS  
    })  
      
    if resp.status_code == 200:  
        print(f"‚úÖ SUCCESS: Created '{title}'")  
        print(f"üîó URL: {resp.json()['url']}")  
    else:  
        print(f"‚ùå Failed: {resp.text}")  
  
if __name__ == "__main__":  
    parser = argparse.ArgumentParser()  
    parser.add_argument("title", help="Issue Title")  
    parser.add_argument("--prio", default="P1", help="Priority")  
    parser.add_argument("--tags", default="Dev", help="Tags")  
    args = parser.parse_args()  
      
    if not NOTION_TOKEN: sys.exit(1)  
    create_issue(args.title, args.prio, args.tags.split(","))  
  
2. src/mt5_bridge/executor.py (Core Logic Implementation)  
The Idempotent Order Executor for Task #012.2  
import logging  
import uuid  
import asyncio  
from typing import Dict, Optional, Union  
from src.mt5_bridge.connection import MT5Connection  
  
logger = logging.getLogger("MT5_Executor")  
  
class OrderExecutor:  
    """  
    MT5 Order Execution Engine with Idempotency Support.  
    """  
    OP_BUY = 0  
    OP_SELL = 1  
      
    def __init__(self, connection: MT5Connection):  
        self.conn = connection  
  
    def _generate_id(self) -> str:  
        return str(uuid.uuid4())  
  
    async def execute_order(self,   
                          symbol: str,   
                          volume: float,   
                          side: str,   
                          comment: str = "MT5-CRS-AI") -> Dict:  
        """  
        Execute trade with strict checks.  
        """  
        side_upper = side.upper()  
        if side_upper not in ["BUY", "SELL"]:  
            return {"retcode": -100, "comment": f"Invalid Side: {side}"}  
              
        op_type = self.OP_BUY if side_upper == "BUY" else self.OP_SELL  
        request_id = self._generate_id()  
          
        payload = {  
            "action": "ORDER_SEND",  
            "request_id": request_id,  
            "symbol": symbol,  
            "volume": float(volume),  
            "type": op_type,  
            "comment": comment,  
            "magic": 123456  
        }  
          
        logger.info(f"üî´ FIRE: {side_upper} {volume} {symbol} [ReqID:{request_id[:8]}]")  
          
        try:  
            # 10s timeout for execution safety  
            response = await self.conn.send_request(payload, timeout=10.0)  
              
            if not response:  
                logger.error(f"‚ùå TIMEOUT: {side_upper} {symbol} [ReqID:{request_id[:8]}]")  
                return {"retcode": -1, "comment": "Network Timeout"}  
                  
            retcode = response.get("retcode")  
            if retcode == 10009: # TRADE_RETCODE_DONE  
                deal = response.get("deal", "Unknown")  
                logger.info(f"‚úÖ FILLED: Deal #{deal} [ReqID:{request_id[:8]}]")  
            else:  
                msg = response.get("comment", "Unknown")  
                logger.warning(f"‚ö†Ô∏è REJECTED: {retcode} - {msg} [ReqID:{request_id[:8]}]")  
                  
            return response  
              
        except Exception as e:  
            logger.error(f"‚ùå EXEC ERROR: {e}")  
            return {"retcode": -2, "comment": str(e)}  
  
if __name__ == "__main__":  
    # Integration Test Stub  
    pass  
