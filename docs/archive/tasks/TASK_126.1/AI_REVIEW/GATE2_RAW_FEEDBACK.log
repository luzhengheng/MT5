[96m[2026-01-18 12:25:42] âœ… ArchitectAdvisor v2.0 å·²åˆå§‹åŒ– (Session: 56de70b8-ff15-43ee-8ba6-b02ef40e2931)[0m
[96m[2026-01-18 12:25:42] ğŸ” å¯åŠ¨å®¡æŸ¥æ¨¡å¼ï¼Œç›®æ ‡æ–‡ä»¶æ•°: 1[0m
[96m[2026-01-18 12:25:42] ğŸ“„ æ­£åœ¨å®¡æŸ¥: scripts/ai_governance/unified_review_gate.py[0m
[96m[2026-01-18 12:25:42] ğŸ‘¤ Persona: ğŸ”’ å®‰å…¨å®˜[0m
[96m[2026-01-18 12:25:42] ğŸ¤– ä½¿ç”¨æ¨¡å‹: claude-opus-4-5-thinking[0m
[96m[2026-01-18 12:25:42] 
ğŸ§  æ­£åœ¨å‘¼å«å¤–éƒ¨å¤§è„‘ (claude-opus-4-5-thinking)...[0m
[96m[2026-01-18 12:25:42] â³ ç³»ç»Ÿå°†æ— é™ç­‰å¾…çœŸå®å“åº” (Protocol v4.4 Wait-or-Die)...[0m
[96m[2026-01-18 12:26:40] âœ… API è°ƒç”¨æˆåŠŸ[0m
[96m[2026-01-18 12:26:40] ğŸ“Š Token Usage: input=7005, output=4000, total=11005[0m

======================================================================
å®¡æŸ¥æŠ¥å‘Š: unified_review_gate.py
======================================================================
Looking at this code, I can see it's a Python script for a "Unified Review Gate" that acts as an AI-powered code review and task planning tool. Let me analyze it and identify any issues or improvements needed.

## Issues Found:

### 1. **Path handling issue in `execute_plan`**
The `os.makedirs` call will fail if `output_file` is just a filename without a directory:

```python
output_path = os.path.join(self.project_root, output_file)
os.makedirs(os.path.dirname(output_path), exist_ok=True)  # dirname of "NEW_TASK.md" is ""
```

### 2. **Potential infinite loop without escape**
The `_send_request` method has a `while True` loop with no maximum retry limit, which could hang indefinitely.

### 3. **Retry counter not tracked**
The log says "ç¬¬ N æ¬¡é‡è¿" but `N` is never actually tracked or incremented.

### 4. **Missing API format handling**
The code assumes OpenAI-compatible API format but uses a `system` field at the top level, which is Anthropic's format. OpenAI uses `messages` with a system role.

Let me provide a corrected version:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Unified Review Gate v2.0 (Architect Edition)
å…¨èƒ½æ¶æ„é¡¾é—®ç½‘å…³ï¼šä»£ç å®¡æŸ¥ + æ–‡æ¡£æ¶¦è‰² + å·¥å•ç”Ÿæˆ
æ ¸å¿ƒå‡çº§ï¼š
â€¢ Context Awareness: è‡ªåŠ¨è¯»å– [MT5-CRS] Central Comman.md æ³¨å…¥é¡¹ç›®èƒŒæ™¯ã€‚
â€¢ Mode Switching: æ”¯æŒ review (å®¡æŸ¥) å’Œ plan (è§„åˆ’) ä¸¤ç§æ¨¡å¼ã€‚
â€¢ Protocol v4.3: å¼ºåˆ¶æ¤å…¥ Zero-Trust éªŒæ”¶æ ‡å‡†ã€‚
Author: Hub Agent
"""

import os
import sys
import argparse
import logging
import uuid
from typing import List
from datetime import datetime

# ============================================================================
# ä¾èµ–å¯¼å…¥ä¸åˆå§‹åŒ–
# ============================================================================

# åŠ è½½ .env æ–‡ä»¶ä¸­çš„ç¯å¢ƒå˜é‡
try:
    from dotenv import load_dotenv
    load_dotenv()
except ImportError:
    print("âš ï¸ [WARN] ç¼ºå°‘ python-dotenvï¼Œå»ºè®®å®‰è£…: pip install python-dotenv")

# å°è¯•å¯¼å…¥ curl_cffi ä¿æŒç½‘ç»œç©¿é€åŠ›
try:
    from curl_cffi import requests
    CURL_AVAILABLE = True
except ImportError:
    print("âš ï¸ [FATAL] ç¼ºå°‘ curl_cffiï¼Œå¿…é¡»å®‰è£…: pip install curl_cffi")
    sys.exit(1)

# é¢œè‰²å®šä¹‰
GREEN = "\033[92m"
RED = "\033[91m"
YELLOW = "\033[93m"
CYAN = "\033[96m"
BLUE = "\033[94m"
RESET = "\033[0m"

# æ—¥å¿—é…ç½®
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - [ARCHITECT] - %(message)s'
)
logger = logging.getLogger("URG_v2")


# ============================================================================
# æ ¸å¿ƒç±»å®šä¹‰
# ============================================================================

class ArchitectAdvisor:
    """å…¨èƒ½æ¶æ„é¡¾é—®ï¼šæ”¯æŒä»£ç å®¡æŸ¥ã€æ–‡æ¡£æ¶¦è‰²ã€å·¥å•ç”Ÿæˆ"""

    # æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œé˜²æ­¢æ— é™å¾ªç¯
    MAX_RETRIES = 50

    def __init__(self):
        """åˆå§‹åŒ–æ¶æ„å¸ˆ"""
        self.session_id = str(uuid.uuid4())
        self.project_root = self._find_project_root()
        self.context_cache = self._load_project_context()

        # åŒæ¨¡å‹æ™ºèƒ½è·¯ç”±é…ç½®
        # æ–‡æ¡£å®¡æŸ¥ï¼ˆğŸ“ æŠ€æœ¯ä½œå®¶ï¼‰ï¼šä½¿ç”¨ gemini-3-pro-previewï¼ˆé•¿ä¸Šä¸‹æ–‡ä¼˜åŠ¿ï¼‰
        self.doc_model = "gemini-3-pro-preview"
        # ä»£ç å®¡æŸ¥ï¼ˆğŸ”’ å®‰å…¨å®˜ï¼‰ï¼šä½¿ç”¨ claude-opus-4-5-thinkingï¼ˆæ·±åº¦æ€è€ƒä¼˜åŠ¿ï¼‰
        self.code_model = "claude-opus-4-5-thinking"

        self.log_file = "VERIFY_URG_V2.log"
        # API å¯†é’¥é…ç½®ï¼šä¼˜å…ˆçº§ VENDOR_API_KEY > GEMINI_API_KEY > CLAUDE_API_KEY
        self.api_key = os.getenv("VENDOR_API_KEY") or os.getenv(
            "GEMINI_API_KEY"
        ) or os.getenv("CLAUDE_API_KEY")
        # API URL é…ç½®ï¼šä¼˜å…ˆçº§ å®Œæ•´è·¯å¾„ > GEMINI_BASE_URL > VENDOR_BASE_URL
        base_url = os.getenv("GEMINI_BASE_URL") or os.getenv(
            "VENDOR_BASE_URL", "https://api.yyds168.net/v1"
        )
        # ç¡®ä¿ API URL åŒ…å«å®Œæ•´è·¯å¾„
        if base_url.endswith("/v1"):
            self.api_url = f"{base_url}/chat/completions"
        else:
            self.api_url = base_url

        # åˆå§‹åŒ–æ—¥å¿—
        self._clear_log()
        msg = (f"âœ… ArchitectAdvisor v2.0 å·²åˆå§‹åŒ– "
               f"(Session: {self.session_id})")
        self._log(msg)

    def _find_project_root(self) -> str:
        """å‘ä¸ŠæŸ¥æ‰¾é¡¹ç›®æ ¹ç›®å½•"""
        current = os.getcwd()
        max_depth = 10
        depth = 0

        while current != "/" and depth < max_depth:
            # æ£€æŸ¥æ˜¯å¦å­˜åœ¨æ ‡è®°æ–‡ä»¶
            if any(os.path.exists(os.path.join(current, f))
                   for f in ["docs/archive/tasks", "src/", "scripts/"]):
                return current
            current = os.path.dirname(current)
            depth += 1

        return os.getcwd()

    def _load_project_context(self) -> str:
        """è¯»å–æ ¸å¿ƒæ–‡æ¡£ä½œä¸ºä¸Šä¸‹æ–‡"""
        context_parts = []

        # 1. è¯»å–ä¸­å¤®å‘½ä»¤æ–‡æ¡£
        central_doc_path = os.path.join(
            self.project_root,
            "docs/archive/tasks/[MT5-CRS] Central Comman.md"
        )
        if os.path.exists(central_doc_path):
            try:
                with open(central_doc_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # æå–å…³é”®ä¿¡æ¯
                    lines = content.split('\n')
                    in_arch = False
                    in_terms = False
                    arch_lines = []
                    term_lines = []

                    for line in lines:
                        if '2ï¸âƒ£ ä¸‰å±‚æ¶æ„è¯¦è§£' in line:
                            in_arch = True
                        elif 'ğŸ“– æœ¯è¯­è¡¨' in line:
                            in_arch = False
                            in_terms = True
                        elif in_arch and line.startswith('##'):
                            in_arch = False

                        if in_arch:
                            arch_lines.append(line)
                        elif in_terms:
                            term_lines.append(line)

                    if arch_lines:
                        context_parts.append("\n".join(arch_lines[:1500]))
                    if term_lines:
                        context_parts.append("\n".join(term_lines[:1000]))

            except OSError as e:
                logger.warning(f"æ— æ³•è¯»å–ä¸­å¤®æ–‡æ¡£: {e}")

        # 2. è¯»å–ä»»åŠ¡æ¨¡æ¿
        task_template_path = os.path.join(self.project_root, "docs/task.md")
        if os.path.exists(task_template_path):
            try:
                with open(task_template_path, 'r', encoding='utf-8') as f:
                    self.task_template_content = f.read()
            except OSError:
                self.task_template_content = ""
        else:
            self.task_template_content = ""

        return "\n".join(context_parts)

    def _log(self, msg: str):
        """æ—¥å¿—è®°å½•"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] {msg}"

        # å†™å…¥æ–‡ä»¶
        with open(self.log_file, 'a', encoding='utf-8') as f:
            f.write(log_entry + '\n')

        # æ‰“å°åˆ°æ§åˆ¶å°
        print(f"{CYAN}{log_entry}{RESET}")

    def _clear_log(self):
        """æ¸…é™¤æ—¥å¿—æ–‡ä»¶"""
        with open(self.log_file, 'w', encoding='utf-8') as f:
            f.write("")

    def _send_request(self, system_prompt: str, user_content: str,
                      model: str = None) -> str:
        """[Protocol v4.4 Enhanced] å‘é€è¯·æ±‚åˆ°å¤–éƒ¨ AI ç½‘å…³

        æ”¹è¿›ç‚¹:
        1. å®æ–½ Wait-or-Die æœºåˆ¶: æœ‰é™é‡è¯•ï¼Œç›´åˆ°è·å–æœ‰æ•ˆå“åº”æˆ–è¾¾åˆ°ä¸Šé™
        2. ç§»é™¤è¶…æ—¶é™åˆ¶: timeout=None é€‚åº”æ·±åº¦æ€è€ƒæ¨¡å‹çš„é•¿è€—æ—¶
        3. æ˜¾å¼çŠ¶æ€åé¦ˆ: æ‰“å°è¯¦ç»†çš„è¿æ¥çŠ¶æ€å’Œç­‰å¾…æç¤º

        Args:
            system_prompt: ç³»ç»Ÿæç¤ºè¯
            user_content: ç”¨æˆ·å†…å®¹
            model: æŒ‡å®šä½¿ç”¨çš„æ¨¡å‹ï¼ˆå¦‚æœä¸ºNoneï¼Œåˆ™ä½¿ç”¨é»˜è®¤çš„gemini-3-pro-previewï¼‰
        """
        if not self.api_key:
            self._log("âš ï¸ ç¯å¢ƒå˜é‡ AI_API_KEY æœªè®¾ç½®ï¼Œä½¿ç”¨æ¼”ç¤ºæ¨¡å¼")
            return self._generate_demo_response(user_content)

        # å¦‚æœæ²¡æœ‰æŒ‡å®šæ¨¡å‹ï¼Œä½¿ç”¨æ–‡æ¡£æ¨¡å‹ä½œä¸ºé»˜è®¤å€¼
        if model is None:
            model = self.doc_model

        import time
        import random

        # åŸºç¡€é€€é¿å‚æ•°
        retry_delay = 5
        max_delay = 60
        retry_count = 0

        self._log(f"\nğŸ§  æ­£åœ¨å‘¼å«å¤–éƒ¨å¤§è„‘ ({model})...")
        self._log("â³ ç³»ç»Ÿå°†ç­‰å¾…çœŸå®å“åº” (Protocol v4.4 Wait-or-Die)...")

        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }

        # ä½¿ç”¨ OpenAI å…¼å®¹æ ¼å¼ï¼ˆsystem ä½œä¸º messages çš„ä¸€éƒ¨åˆ†ï¼‰
        payload = {
            "model": model,
            "max_tokens": 4000,
            "temperature": 0.3,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_content}
            ]
        }

        while retry_count < self.MAX_RETRIES:
            retry_count += 1
            try:
                # å…³é”®: timeout=None å…è®¸ socket æ— é™æœŸä¿æŒè¿æ¥
                response = requests.post(
                    self.api_url,
                    json=payload,
                    headers=headers,
                    impersonate="chrome110",
                    timeout=None
                )

                # 200 OK: å”¯ä¸€åˆæ³•çš„å‡ºå£
                if response.status_code == 200:
                    try:
                        res_json = response.json()
                        result_text = res_json['choices'][0]['message']['content']
                        usage = res_json.get('usage', {})

                        input_tokens = usage.get('prompt_tokens', 0)
                        output_tokens = usage.get('completion_tokens', 0)
                        total_tokens = input_tokens + output_tokens

                        self._log("âœ… API è°ƒç”¨æˆåŠŸ")
                        msg = (f"ğŸ“Š Token Usage: input={input_tokens}, "
                               f"output={output_tokens}, total={total_tokens}")
                        self._log(msg)

                        return result_text
                    except (KeyError, IndexError, TypeError) as json_err:
                        self._log(f"âŒ JSON è§£æå¼‚å¸¸: {json_err}")
                        # JSON é”™è¯¯é€šå¸¸æ˜¯ä¼ è¾“æˆªæ–­ï¼Œå±äºé‡è¯•èŒƒç•´

                # 429/5xx: æ ‡å‡†é‡è¯•åœºæ™¯
                elif response.status_code in [429, 500, 502, 503, 504]:
                    self._log(f"ğŸŒŠ æµé‡æ§åˆ¶/æœåŠ¡ç¹å¿™ (HTTP {response.status_code})...")

                # 4xx (400/401): é…ç½®é”™è¯¯
                elif response.status_code in [400, 401, 403]:
                    self._log(f"ğŸ›‘ è‡´å‘½é…ç½®é”™è¯¯ (HTTP {response.status_code}): "
                              f"{response.text[:200]}...")
                    self._log("âš ï¸ è¯·æ£€æŸ¥ .env é…ç½®æˆ– API Keyã€‚")
                    # é…ç½®é”™è¯¯ä¸åº”æ— é™é‡è¯•ï¼Œè¿”å›é”™è¯¯ä¿¡æ¯
                    return f"âŒ API é…ç½®é”™è¯¯ (HTTP {response.status_code}): {response.text[:200]}"

                else:
                    self._log(f"âš ï¸ æœªçŸ¥å“åº” (HTTP {response.status_code})")

            except Exception as e:
                # æ•è·æ‰€æœ‰ç½‘ç»œå±‚å¼‚å¸¸ (ConnectionReset, ChunkedEncodingError ç­‰)
                self._log(f"ğŸ”Œ ç½‘ç»œæ³¢åŠ¨: {str(e)}")

            # æŒ‡æ•°é€€é¿ (Exponential Backoff)
            sleep_time = min(retry_delay, max_delay)
            # æ·»åŠ éšæœºæŠ–åŠ¨ï¼Œé˜²æ­¢å…±æŒ¯
            jitter = random.uniform(0, 3)
            total_sleep = sleep_time + jitter

            self._log(f"ğŸ”„ {total_sleep:.1f}ç§’åå‘èµ·ç¬¬ {retry_count + 1} æ¬¡é‡è¿... "
                      f"(å‰©ä½™ {self.MAX_RETRIES - retry_count} æ¬¡)")
            time.sleep(total_sleep)

            # å¢åŠ ä¸‹ä¸€æ¬¡ç­‰å¾…åŸºæ•°
            retry_delay = min(retry_delay * 1.5, max_delay)

        # è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°
        self._log(f"âŒ å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•° ({self.MAX_RETRIES})ï¼Œæ”¾å¼ƒè¯·æ±‚")
        return "âŒ API è¯·æ±‚å¤±è´¥ï¼šå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°"

    def _generate_demo_response(self, user_content: str) -> str:
        """æ¼”ç¤ºæ¨¡å¼ï¼šç”Ÿæˆç¤ºä¾‹è¾“å‡ºï¼ˆç”¨äºæµ‹è¯•ï¼‰"""
        self._log("ğŸ“ ä½¿ç”¨æ¼”ç¤ºæ¨¡å¼ç”Ÿæˆç¤ºä¾‹å†…å®¹...")

        if "ä»»åŠ¡éœ€æ±‚:" in user_content:
            # Plan æ¨¡å¼çš„ç¤ºä¾‹å“åº”
            return """# TASK_125: EODHD æ•°æ®æºåˆæ­¥æ¥å…¥

**Protocol**: v4.3 (Zero-Trust Edition)
**Priority**: High
**Status**: æ–°å»º

## 1. ä»»åŠ¡å®šä¹‰ (Definition)

### 1.1 æ ¸å¿ƒç›®æ ‡
å®ç°ä» EODHD API ä¸‹è½½å†å² OHLCV æ•°
======================================================================

