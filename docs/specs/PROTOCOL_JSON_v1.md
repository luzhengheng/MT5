# MT5-CRS JSON 交易协议 v1.0

**版本**: v1.0
**发布日期**: 2026-01-04
**状态**: 正式版 (Production Ready)
**协议**: v4.0 (Sync-Enforced)

---

## 1. 概述

### 1.1 目标
定义 Python 策略引擎与 MT5 执易执行的标准化 JSON 通信协议，替代字符串消息，实现：
- ✅ 结构化命令和响应
- ✅ 强类型验证
- ✅ 完整的错误处理
- ✅ 网络重传的幂等性保证
- ✅ 支持止损/止盈等高级特性

### 1.2 架构

```
┌──────────────────────────────────────────────────┐
│   Python 策略引擎 (Linux INF)                    │
│   - 信号生成                                      │
│   - 风险管理                                      │
│   - 仓位计算                                      │
│   - 发送 JSON 命令                               │
└────────────────────┬─────────────────────────────┘
                     │
           ZMQ REQ/REP (5555)
           TCP://172.19.141.255:5555
                     │
┌────────────────────▼─────────────────────────────┐
│   Windows Gateway (GTW)                          │
│   - JSON 解析 & 验证                             │
│   - 幂等性检查                                   │
│   - 路由到 MT5                                   │
└────────────────────┬─────────────────────────────┘
                     │
           Windows 管道 / 本地 API
                     │
┌────────────────────▼─────────────────────────────┐
│   MetaTrader 5 EA                                │
│   - JSON 字符串解析                              │
│   - OrderSend() 执行                            │
│   - 返回结果                                     │
└──────────────────────────────────────────────────┘
```

### 1.3 通讯模式

| 方向 | 套接字 | 模式 | 端口 | 超时 |
|:---|:---|:---|:---|:---|
| **请求** | REQ | 同步阻塞 | 5555 | 2-10s |
| **响应** | REP | 双向 | 5555 | 同上 |

---

## 2. 请求格式 (Request)

### 2.1 基础结构

所有请求都采用以下 JSON 结构：

```json
{
  "action": "ORDER_SEND",
  "req_id": "550e8400-e29b-41d4-a716-446655440000",
  "timestamp": 1704067200.123456,
  "payload": {
    "symbol": "EURUSD",
    "type": "OP_BUY",
    "volume": 0.01,
    "magic": 123456,
    "comment": "MT5-CRS-AI",
    "sl": 1.04500,
    "tp": 1.06000
  }
}
```

### 2.2 字段说明

| 字段 | 类型 | 必需 | 说明 |
|:---|:---|:---|:---|
| `action` | string | ✅ | 操作类型（见 2.3） |
| `req_id` | string | ✅ | 唯一请求 ID (UUID v4)，用于幂等性 |
| `timestamp` | float | ❌ | 请求时间戳（秒.微秒），默认当前时间 |
| `payload` | object | ✅ | 业务数据 |

### 2.3 Action 类型

#### 2.3.1 ORDER_SEND - 发送订单

**用途**: 开仓（买入或卖出）

**Payload 字段**:

| 字段 | 类型 | 必需 | 范围 | 说明 |
|:---|:---|:---|:---|:---|
| `symbol` | string | ✅ | "EURUSD", "GBPUSD" 等 | 品种代码 |
| `type` | string | ✅ | "OP_BUY" 或 "OP_SELL" | 交易方向 |
| `volume` | float | ✅ | 0.01 - 100.0 | 手数 |
| `magic` | int | ❌ | 0 - 2147483647 | 策略标识（默认 123456） |
| `comment` | string | ❌ | 最多 31 字符 | 订单备注（默认 "MT5-CRS-AI"） |
| `sl` | float | ❌ | > 0 或 0 | 止损价格（0 = 无止损） |
| `tp` | float | ❌ | > 0 或 0 | 止盈价格（0 = 无止盈） |

**示例请求**:

```json
{
  "action": "ORDER_SEND",
  "req_id": "550e8400-e29b-41d4-a716-446655440000",
  "payload": {
    "symbol": "EURUSD",
    "type": "OP_BUY",
    "volume": 0.01,
    "magic": 123456,
    "comment": "Signal generated by AI",
    "sl": 1.04500,
    "tp": 1.06000
  }
}
```

**预期响应**:
```json
{
  "error": false,
  "ticket": 100234567,
  "msg": "Filled at 1.05123",
  "retcode": 10009
}
```

#### 2.3.2 ORDER_MODIFY - 修改订单 (Future)

**状态**: 预留，v1.1 实现

#### 2.3.3 ORDER_CLOSE - 平仓 (Future)

**状态**: 预留，v1.1 实现

#### 2.3.4 DATA_REQ - 数据查询 (Future)

**状态**: 预留，v1.1 实现

---

## 3. 响应格式 (Response)

### 3.1 基础结构

所有响应都采用以下统一格式：

```json
{
  "error": false,
  "ticket": 100234567,
  "msg": "Order filled successfully",
  "retcode": 10009,
  "data": null
}
```

### 3.2 字段说明

| 字段 | 类型 | 说明 |
|:---|:---|:---|
| `error` | bool | `false` = 成功，`true` = 失败 |
| `ticket` | int | 订单号（成功时 > 0，失败时 = 0） |
| `msg` | string | 描述信息或错误原因 |
| `retcode` | int | MT5 返回码（见 3.3） |
| `data` | object/null | 扩展数据（保留） |

### 3.3 返回码 (Return Code)

#### 成功码

| 代码 | 名称 | 说明 |
|:---|:---|:---|
| 10009 | `TRADE_RETCODE_DONE` | 交易执行成功 |
| 10010 | `TRADE_RETCODE_DONE_PARTIAL` | 部分成交 |

#### 错误码（MT5 原生）

| 代码 | 名称 | 说明 | 处理建议 |
|:---|:---|:---|:---|
| 10013 | `TRADE_RETCODE_INVALID_VOLUME` | 无效手数 | 检查 volume 范围（0.01-100） |
| 10014 | `TRADE_RETCODE_INVALID_PRICE` | 无效价格 | 检查 sl/tp 价格有效性 |
| 10015 | `TRADE_RETCODE_INVALID_STOPS` | 无效止损/止盈 | sl/tp 距当前价格太近 |
| 10027 | `TRADE_RETCODE_REQUOTE` | 需要重新报价 | 市场波动，重试一次 |
| 10019 | `TRADE_RETCODE_NOT_ENOUGH_MONEY` | 资金不足 | 降低手数或等待保证金释放 |
| 10016 | `TRADE_RETCODE_MARKET_CLOSED` | 市场关闭 | 等待市场开盘 |
| 10017 | `TRADE_RETCODE_DISABLED` | 交易被禁用 | 检查账户权限 |
| 10018 | `TRADE_RETCODE_FROZEN` | 订单被冻结 | 等待解冻 |

#### 自定义错误码

| 代码 | 名称 | 说明 |
|:---|:---|:---|
| -1 | 解析失败 | JSON 格式错误 |
| -2 | 字段缺失 | 必需字段不存在 |
| -3 | 字段无效 | 字段值超出范围 |
| -4 | 超时 | 请求处理超时 |

### 3.4 响应示例

**成功**:
```json
{
  "error": false,
  "ticket": 100234567,
  "msg": "Filled at 1.05123",
  "retcode": 10009,
  "data": null
}
```

**部分成交**:
```json
{
  "error": false,
  "ticket": 100234568,
  "msg": "Partial fill: 0.005 at 1.05120",
  "retcode": 10010,
  "data": null
}
```

**资金不足**:
```json
{
  "error": true,
  "ticket": 0,
  "msg": "Not enough money. Required: 150 USD, Available: 120 USD",
  "retcode": 10019,
  "data": null
}
```

**解析错误**:
```json
{
  "error": true,
  "ticket": 0,
  "msg": "Invalid JSON: missing field 'symbol'",
  "retcode": -2,
  "data": null
}
```

---

## 4. 幂等性机制

### 4.1 目标

防止网络重传导致重复成交。

### 4.2 实现方案

**步骤 1: Python 生成 UUID**
```python
import uuid
req_id = str(uuid.uuid4())  # "550e8400-e29b-41d4-a716-446655440000"
```

**步骤 2: 附加到请求**
```json
{
  "action": "ORDER_SEND",
  "req_id": "550e8400-e29b-41d4-a716-446655440000",
  "payload": {...}
}
```

**步骤 3: Gateway 建立缓存映射**
```python
uuid_ticket_cache = {}  # {uuid: ticket}

if req_id in uuid_ticket_cache:
    # 重复请求，返回原始 Ticket
    return {"error": false, "ticket": uuid_ticket_cache[req_id], "msg": "Cached"}
else:
    # 新请求，执行订单
    ticket = execute_order(payload)
    uuid_ticket_cache[req_id] = ticket
    return {"error": false, "ticket": ticket, "msg": "Filled"}
```

**步骤 4: 清理机制**
- 缓存保留 1 小时（可配置）
- 缓存大小上限：10000 条
- 超时或超额时采用 LRU 淘汰

### 4.3 UUID 格式

- **标准**: UUID v4（随机生成）
- **长度**: 36 字符（含连字符）
- **示例**: `550e8400-e29b-41d4-a716-446655440000`
- **冲突概率**: < 1 in 5.3×10^36

---

## 5. 数据类型约束

### 5.1 Symbol (品种代码)

- **格式**: 大写字母 + 可选后缀（如 `EURUSD`, `EURUSD.s`）
- **范围**: 6-10 字符
- **有效范围**: 外汇主要品种（EURUSD, GBPUSD, USDJPY 等）
- **校验**: 长度检查 + 字符集检查

### 5.2 Volume (手数)

- **格式**: 浮点数
- **范围**: 0.01 - 100.0
- **精度**: 最多 2 位小数（如 0.01, 0.5, 1.0）
- **约束**: 不能超过账户最大手数限制
- **校验**:
  ```python
  assert 0.01 <= volume <= 100.0
  assert volume % 0.01 == 0  # 0.01 的倍数
  ```

### 5.3 Price (价格)

- **格式**: 浮点数（4-5 位小数）
- **范围**: > 0（通常 0.5 - 3.0）
- **约束**: sl < current_price < tp（买入）或 tp < current_price < sl（卖出）
- **校验**:
  ```python
  assert price > 0
  assert sl == 0 or sl > 0
  assert tp == 0 or tp > 0
  if side == "BUY":
      assert sl < current_price < tp or (sl == 0 and tp == 0)
  ```

### 5.4 Magic (策略标识)

- **格式**: 整数（0-2147483647）
- **默认**: 123456
- **用途**: 区分不同策略的订单
- **约束**: 每个策略一个固定的 Magic 号

### 5.5 Comment (备注)

- **格式**: 字符串
- **最大长度**: 31 字符（MT5 限制）
- **编码**: UTF-8
- **示例**: "MT5-CRS-AI", "Signal generated"

---

## 6. 错误处理指南

### 6.1 Python 端处理

```python
def trade(symbol, order_type, volume, sl=0.0, tp=0.0):
    """发送 JSON 交易指令"""
    try:
        response = zmq_client.send_json({
            "action": "ORDER_SEND",
            "req_id": str(uuid.uuid4()),
            "payload": {
                "symbol": symbol,
                "type": order_type,
                "volume": volume,
                "sl": sl,
                "tp": tp
            }
        })

        if response["error"]:
            # 业务失败
            error_msg = response["msg"]
            retcode = response["retcode"]

            if retcode == 10019:  # 资金不足
                logger.warning(f"Insufficient margin: {error_msg}")
                return None
            elif retcode == 10027:  # 需要重新报价
                # 可重试一次
                return retry_trade(...)
            else:
                logger.error(f"Trade failed: {error_msg} (code: {retcode})")
                return None
        else:
            # 成功
            ticket = response["ticket"]
            logger.info(f"Order placed: #{ticket}")
            return ticket

    except zmq.Again:
        # 网络超时（2-10s）
        logger.error("ZMQ timeout - gateway unreachable")
        return None
    except Exception as e:
        # 异常错误
        logger.error(f"Unexpected error: {e}")
        return None
```

### 6.2 Gateway 端处理

```python
def _process_json_request(self, json_data):
    """处理 JSON 请求"""
    try:
        # 步骤 1: 字段验证
        action = json_data.get("action")
        req_id = json_data.get("req_id")
        payload = json_data.get("payload", {})

        if not action:
            return {"error": true, "ticket": 0, "msg": "Missing 'action'", "retcode": -2}

        if not req_id:
            return {"error": true, "ticket": 0, "msg": "Missing 'req_id'", "retcode": -2}

        # 步骤 2: 幂等性检查
        if req_id in self.uuid_ticket_cache:
            return {
                "error": false,
                "ticket": self.uuid_ticket_cache[req_id],
                "msg": "Cached result (idempotent)",
                "retcode": 10009
            }

        # 步骤 3: 执行订单
        if action == "ORDER_SEND":
            result = self.execute_order(payload)
            ticket = result.get("ticket", 0)
            retcode = result.get("retcode")

            if retcode == 10009 and ticket > 0:
                self.uuid_ticket_cache[req_id] = ticket

            return {
                "error": retcode != 10009,
                "ticket": ticket,
                "msg": result.get("msg", "Unknown"),
                "retcode": retcode
            }

    except json.JSONDecodeError:
        return {"error": true, "ticket": 0, "msg": "Invalid JSON", "retcode": -1}
    except KeyError as e:
        return {"error": true, "ticket": 0, "msg": f"Missing field: {e}", "retcode": -2}
    except Exception as e:
        return {"error": true, "ticket": 0, "msg": str(e), "retcode": -4}
```

### 6.3 MQL5 EA 处理

```mql5
void OnTimer() {
    string json_str = zmq_receive();
    if (json_str == "") return;

    OrderRequest req;
    if (!ParseOrderJson(json_str, req)) {
        SendOrderResponse(true, 0, "JSON parse failed", -1);
        return;
    }

    ulong ticket = 0;
    int retcode = 0;
    if (!ExecuteOrder(req, ticket, retcode)) {
        SendOrderResponse(true, 0, "OrderSend failed", retcode);
        return;
    }

    SendOrderResponse(false, ticket, "Filled", 10009);
}
```

---

## 7. 性能指标

### 7.1 目标

| 指标 | 目标 | 说明 |
|:---|:---|:---|
| **往返延迟** | < 100ms | 包括网络传输 + 处理 |
| **吞吐量** | > 100 orders/sec | 单条连接 |
| **可靠性** | > 99.9% | 成功率 |
| **幂等性覆盖** | 100% | 所有重传请求 |

### 7.2 监控指标

```python
# 延迟监控
start_time = time.time()
response = zmq_client.send_json(request)
latency_ms = (time.time() - start_time) * 1000

# 记录
if latency_ms > 100:
    logger.warning(f"High latency: {latency_ms}ms")
elif latency_ms < 10:
    logger.debug(f"Fast response: {latency_ms}ms")
else:
    logger.info(f"Normal latency: {latency_ms}ms")
```

---

## 8. 完整示例

### 8.1 买入 EURUSD

```python
# Python 端
import uuid
import json
import zmq

context = zmq.Context()
socket = context.socket(zmq.REQ)
socket.connect("tcp://172.19.141.255:5555")

request = {
    "action": "ORDER_SEND",
    "req_id": str(uuid.uuid4()),
    "payload": {
        "symbol": "EURUSD",
        "type": "OP_BUY",
        "volume": 0.01,
        "magic": 123456,
        "comment": "AI Signal",
        "sl": 1.04500,
        "tp": 1.06000
    }
}

# 发送请求
socket.send_json(request)

# 接收响应
response = socket.recv_json(timeout=5000)

print(f"Order #{response['ticket']}: {response['msg']}")
# Output: Order #100234567: Filled at 1.05123
```

### 8.2 处理错误

```python
if response["error"]:
    if response["retcode"] == 10019:
        print(f"Insufficient margin: {response['msg']}")
    else:
        print(f"Error {response['retcode']}: {response['msg']}")
else:
    print(f"Success: Ticket {response['ticket']}")
```

---

## 9. 版本历史

| 版本 | 日期 | 变更 |
|:---|:---|:---|
| v1.0 | 2026-01-04 | 初始版本，支持 ORDER_SEND，包含幂等性机制 |
| v1.1 (plan) | TBD | 支持 ORDER_MODIFY、ORDER_CLOSE |
| v2.0 (plan) | TBD | 支持请求签名验证，消息压缩 |

---

## 10. 参考资源

- **ZMQ 文档**: http://zguide.zeromq.org/
- **MT5 API**: https://www.mql5.com/en/docs/constants/tradingconstants/enum_trade_request_actions
- **UUID 规范**: RFC 4122

---

**文档维护者**: MT5-CRS Project Team
**最后更新**: 2026-01-04
**下次审查**: 2026-02-04
