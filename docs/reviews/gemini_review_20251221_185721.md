# Gemini Pro 代码审查报告

**时间**: 2025-12-21T18:57:21.393557

## 审查请求

```
# MT5-CRS 项目审查请求

## 项目概览
- **项目名称**: MT5-CRS
- **当前阶段**: 工单 #011 实盘交易系统对接
- **最后更新**: 2025-12-21T18:56:36.867983
- **当前焦点**: MT5 API 集成与实盘交易系统

## Git 状态
- **当前分支**: Unknown
- **最新提交**: No commits
- **未提交更改**: 0 个文件

## 优先任务
- 无法获取优先任务信息

## AI Command Center 最新任务
- 无法获取AI任务信息

## 核心代码审查

### 📄 src/strategy/risk_manager.py
```python
"""
风险管理模块 - Kelly Criterion 注码策略与动态风控

核心组件：
1. KellySizer: 基于 Kelly 公式的动态仓位管理
2. DynamicRiskManager: 账户级风险监控和熔断机制
"""

import backtrader as bt
import numpy as np
import logging
from typing import Optional

logger = logging.getLogger(__name__)


class KellySizer(bt.Sizer):
    """
    Kelly Criterion 仓位管理器（通用公式版本）

    公式：
        f* = [p(b+1) - 1] / b

    其中：
        - f*: Kelly 风险比例（Optimal Risk Fraction）
        - p: 预测胜率（从 ML 模型输出的 y_pred_proba）
        - b: 赔率（策略的 take_profit_ratio，即盈亏比）

    仓位计算：
        Risk Amount = Account Value * f* * kelly_fraction
        Position Size = Risk Amount / (ATR * stop_loss_multiplier)

    重要区别：
        - f* 是"风险...
```

## 审查结果

你好！我是你的量化交易系统开发专家。针对你提供的 **MT5-CRS** 项目代码片段及当前阶段（MT5 实盘对接），我进行了深度的代码审查和架构评估。

由于你正处于 **工单 #011 实盘交易系统对接** 的关键阶段，我的审查将特别关注代码在**实盘环境（Live Trading）**下的健壮性、延迟敏感度和风控安全性。

---

## 1. 核心代码审查

### 📄 `src/strategy/risk_manager.py` (KellySizer)

这是一个基于 Kelly 公式的仓位管理模块。在回测中它可能表现良好，但在实盘 MT5 环境中存在重大隐患。

**🔴 严重问题 (Critical):**
1.  **实盘资金获取 (`self.broker.getvalue()`)**:
    *   在 Backtrader 对接 MT5 时，`getvalue()` 通常返回的是 **动态权益 (Equity)** 而非 **余额 (Balance)**。
    *   **风险**: 当你有持仓且浮动盈亏波动时，Equity 会剧烈跳动，导致下一笔交易计算出的 Kelly 仓位忽大忽小（仓位震荡）。
    *   **建议**: 在实盘中，建议基于 `broker.getcash()` (可用资金) 或固定的初始资金模型来计算 Kelly，或者对 Equity 进行平滑处理。
2.  **数据字段依赖 (`data.y_pred_proba_long`)**:
    *   代码假设 `data` 对象中已经有了 ML 模型的预测概率。在实盘模式下，这意味着你必须在 `next()` 被调用之前，实时完成特征工程和模型推理，并将结果注入到 DataFeed 中。
    *   **风险**: 如果推理延迟导致数据未及时注入，或者注入了 `NaN`，`_getsizing` 返回 0，导致漏单。

**🟡 优化建议 (Improvement):**
1.  **Kelly 边界保护**: 虽然你有 `max_position_pct`，但 Kelly 公式在极端概率下（如模型过拟合输出 0.99 胜率）会给出极高杠杆建议。建议增加 `max_leverage` (最大杠杆率) 的硬约束。
2.  **ATR 获取**: 代码注释提到了 `Risk Amount / (ATR * multiplier)`，但代码片段中未显示 ATR 的计算逻辑。在实盘中，确保 ATR 是基于已确定的 bar 计算的，避免未来函数。

### 📄 `nexus_with_proxy.py` (Notion Nexus)

这是一个辅助脚本，用于连接 Notion 和 LLM。

**🟡 架构问题 (Architecture):**
1.  **阻塞风险**: 这是典型的同步 IO 代码 (`requests.post`)。如果在交易主循环中直接调用此脚本（例如用于发送交易日志到 Notion），会导致整个交易系统卡顿，错过行情。
    *   **建议**: 必须将此功能放入 **异步任务队列 (如 Celery)** 或 **独立线程** 中运行。
2.  **API 版本硬编码**: `gemini-2.5-flash` 和 `gemini-2.0-flash-exp` 是实验性或特定版本。Google 经常废弃旧模型。
    *   **建议**: 将模型名称提取到 `.env` 配置中。

### 📂 `src/feature_engineering/`

虽然没有具体代码，但针对实盘特征工程，我有以下提醒：

**⚠️ 实盘陷阱 (Pitfall):**
1.  **增量计算 vs 全量计算**: 训练时通常对整个 DataFrame 做 `rolling`。实盘时，每来一个 Tick 或 Bar，你不能重新计算整个历史数据的指标（太慢）。你需要实现**增量计算 (Incremental Calculation)** 或只取最近 N 个 Bar 进行滑动窗口计算。
2.  **数据一致性**: 必须确保实盘代码计算出的特征值，与训练模型时计算的值**完全一致**（精度、填充方式、Look-ahead bias）。哪怕 0.0001 的偏差都可能导致模型预测翻转。

---

## 2. 架构评估与 MT5 实盘对接建议

你当前关注的是 **MT5 API 集成**。由于 Git 中没有提交 MT5 相关的代码，我基于行业最佳实践为你构建架构蓝图。

### 核心架构图 (推荐)

```mermaid
graph TD
    MT5[MT5 Terminal] <-->|MetaTrader5 Python Lib| Bridge[MT5 Data/Order Bridge]
    Bridge -->|Tick/Bar Data| FeatureEng[特征工程模块]
    FeatureEng -->|Feature Vector| MLModel[ML 推理引擎]
    MLModel -->|Signal & Prob| Strategy[Backtrader/Custom Strategy]
    Strategy -->|Size Calculation| RiskMgr[Risk Manager (Kelly)]
    RiskMgr -->|Order Request| Bridge
    Bridge -->|Execute| MT5
    
    subgraph "非核心路径 (异步)"
        Strategy -.->|Log| Nexus[Notion Nexus]
    end
```

### 关键决策点

#### 1. 连接方式：官方库 vs ZeroMQ
*   **推荐**: 使用官方 **`MetaTrader5` Python 库**。
*   **理由**: 相比旧式的 ZeroMQ 方案，官方库更稳定，支持直接内存读取数据，延迟更低，且不需要在 MT5 中挂载复杂的 EA。
*   **注意**: 官方库是同步阻塞的。在获取数据或下单时，需要注意不要阻塞策略主循环。

#### 2. 实时数据流 (The Loop)
实盘系统不能像回测那样简单地 iterate。你需要一个事件驱动的循环：

```python
# 伪代码示例
import MetaTrader5 as mt5

def live_trading_loop():
    if not mt5.initialize():
        logger.error("MT5 init failed")
        return

    while True:
        # 1. 获取最新数据 (只获取最近需要的 Candle)
        rates = mt5.copy_rates_from_pos(SYMBOL, TIMEFRAME, 0, LOOKBACK_BARS)
        
        # 2. 检查是否有新 Bar 生成 (避免重复计算)
        if is_new_bar(rates):
            # 3. 特征工程 (确保计算速度 < 1秒)
            features = feature_engineer.calculate(rates)
            
            # 4. 模型推理
            signal, prob = model.predict(features)
            
            # 5. 风控与仓位
            size = risk_manager.get_size(account_info, prob)
            
            # 6. 执行
            if size != 0:
                execute_order(symbol, size)
                
        time.sleep(0.1) # 防止 CPU 100%
```

---

## 3. 风险评估 (Risk Assessment)

| 风险点 | 严重性 | 描述 | 缓解措施 |
| :--- | :---: | :--- | :--- |
| **执行延迟** | 高 | Python 特征计算+模型推理耗时过长，导致信号生成时价格已变动。 | 优化 Pandas 代码；使用 Cython/Numba；在 Bar 关闭前 N 秒预计算。 |
| **滑点失控** | 中 | MT5 市价单在剧烈波动时成交价偏离预期。 | 必须使用 `deviation` 参数限制滑点；或使用 Limit 单代替 Market 单。 |
| **状态不同步** | 高 | Python 认为持仓，MT5 端因爆仓或人工干预已平仓。 | 每次循环开始时，必须调用 `mt5.positions_get()` 强制同步持仓状态。 |
| **API 限制** | 低 | 频繁请求导致 MT5 终端卡死或被经纪商限流。 | 缓存静态数据（如合约规格）；控制轮询频率。 |

---

## 4. 具体的改进建议 (Actionable Items)

### 优先级 P0 (必须解决)
1.  **实现 MT5 桥接类**: 创建一个 `MT5Bridge` 类，封装 `initialize`, `copy_rates`, `order_send`, `positions_get` 等方法。包含重试机制和错误处理（处理 MT5 返回的错误码）。
2.  **完善 RiskManager**: 修改 `KellySizer`，使其能够接收实盘的 `Account Balance` 而非 `Equity`，并增加 `max_risk_per_trade` (单笔最大亏损金额) 的硬性风控。
3.  **对齐特征工程**: 编写一个单元测试，对比 "离线计算的一批数据" 和 "模拟实盘逐条喂入计算的数据"，确保结果矩阵完全一致。

### 优先级 P1 (建议优化)
1.  **异步日志**: 将 `nexus_with_proxy.py` 的调用改为异步，或者仅将日志写入本地文件，由另一个独立进程（Filebeat/Logstash 或自定义脚本）读取并推送到 Notion。
2.  **异常熔断**: 在主循环中增加全局 `try-except`，一旦发生未捕获异常或连续亏损超过阈值，立即停止交易并发送紧急通知（Telegram/SMS）。

### 优先级 P2 (未来规划)
1.  **多周期对齐**: 如果策略需要多周期数据（如 H1 趋势 + M5 入场），MT5 的多周期数据同步比较麻烦，需要专门的时间戳对齐逻辑。

## 总结
MT5-CRS 目前的代码片段展示了良好的量化思维（如 Kelly 公式），但在从“回测代码”转向“实盘系统”时，需要重点解决**状态同步**、**执行延迟**和**错误处理**这三大挑战。

**下一步行动**: 请创建 `src/connection/mt5_bridge.py`，并实现基础的连接和数据获取功能，我们可以针对该文件进行下一轮审查。
