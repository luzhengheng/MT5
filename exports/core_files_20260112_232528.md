# 核心代码文件

## src/strategy/risk_manager.py

```python
"""
风险管理模块 - Kelly Criterion 注码策略与动态风控 (Architect Approved)
"""

import backtrader as bt
import numpy as np
import math
import logging
from typing import Optional
from src.strategy.session_risk_manager import SessionRiskManager, get_session_risk_manager

logger = logging.getLogger(__name__)

class KellySizer(bt.Sizer):
    """
    Kelly Criterion 仓位管理器 (MT5 实盘优化版)
    包含: 手数取整 (Lot Quantization)、实盘资金检查、ATR 保护
    """

    params = (
        ('kelly_fraction', 0.25),  # 四分之一 Kelly
        ('max_position_pct', 0.50),
        ('min_position_pct', 0.01),
        ('stop_loss_multiplier', 2.0),
        ('max_leverage', 3.0),
        ('max_risk_per_trade', 0.02),
        ('use_hierarchical_signals', True),
        ('lot_step', 0.01),  # MT5 标准最小手数步长
    )

    def _get_win_probability(self, data, isbuy: bool) -> Optional[float]:
        """获取交易胜率 (优先使用 ML 置信度)"""
        p_win = None
        if self.params.use_hierarchical_signals:
            try:
                if hasattr(self.strategy, 'hierarchical_signals'):
                    fusion = self.strategy.hierarchical_signals.get_last_signal()
                    if fusion: return fusion.confidence
            except: pass
        
        # 回退到数据源
        try:
            p_win = data.y_pred_proba_long[0] if isbuy else data.y_pred_proba_short[0]
            if not np.isnan(p_win) and p_win > 0: return p_win
        except: pass
        return None

    def _getsizing(self, comminfo, cash, data, isbuy):
        """计算仓位大小 (核心逻辑)"""
        # 1. 获取账户价值 (实盘优先使用 getcash)
        if hasattr(self.broker, 'getcash'):
            account_value = self.broker.getcash()
        else:
            account_value = self.broker.getvalue()

        current_price = data.close[0]
        if current_price <= 0: return 0

        # 2. 获取胜率 & 赔率
        p_win = self._get_win_probability(data, isbuy)
        if not p_win: return 0
        
        b = getattr(self.strategy.params, 'take_profit_ratio', 2.0)
        
        # 3. Kelly 公式
        kelly_f = (p_win * (b + 1) - 1) / b
        if kelly_f <= 0: return 0
        
        risk_pct = kelly_f * self.params.kelly_fraction
        
        # 4. 硬性风控约束
        risk_pct = min(risk_pct, self.params.max_risk_per_trade)
        max_risk_amt = account_value * risk_pct

        # 5. ATR 计算
        try:
            atr = self.strategy.atr[0]
        except:
            # 架构师要求：如果没有 ATR，不要瞎猜，直接拒绝开仓
            logger.warning("ATR data missing, skipping trade for safety.")
            return 0

        if atr <= 0: return 0
        
        # 6. 计算止损距离与原始仓位
        sl_dist = atr * self.params.stop_loss_multiplier
        if sl_dist == 0: return 0
        
        raw_size = max_risk_amt / sl_dist

        # 7. 杠杆检查
        if (raw_size * current_price) > (account_value * self.params.max_leverage):
            raw_size = (account_value * self.params.max_leverage) / current_price

        # 8. ✅ MT5 手数取整 (Lot Quantization) - 关键修复
        # 向下取整到最近的 lot_step (如 0.01)
        step = self.params.lot_step
        size = math.floor(raw_size / step) * step
        
        # 9. 最小手数检查
        if size < step:
            return 0

        logger.info(f"Sizer: P={p_win:.2f} Risk%={risk_pct:.1%} Size={size:.2f} (Price={current_price:.2f})")
        
        return size

class DynamicRiskManager:
    """动态风险管理器 (保留原有逻辑)"""
    def __init__(self, broker, max_drawdown_pct=10.0, stop_trading_on_breach=True, daily_loss_limit=-0.05):
        self.broker = broker
        self.max_drawdown_pct = max_drawdown_pct / 100.0
        self.stop_trading_on_breach = stop_trading_on_breach
        self.peak_value = broker.getvalue()
        self.is_halted = False
        self.session_risk = get_session_risk_manager(daily_loss_limit)

    def update(self):
        val = self.broker.getvalue()
        if val > self.peak_value: 
            self.peak_value = val
            self.is_halted = False
        
        dd = (self.peak_value - val) / self.peak_value
        if dd > self.max_drawdown_pct: self.is_halted = True
        return {'drawdown': dd, 'is_halted': self.is_halted}

    def can_trade(self):
        if self.is_halted: return False
        if not self.session_risk.can_trade(): return False
        return True

```

## src/feature_engineering/basic_features.py

```python
"""
基础技术指标特征计算
使用 pandas 和 numpy 实现（避免 ta-lib 依赖）
"""

import numpy as np
import pandas as pd
import logging

logger = logging.getLogger(__name__)


class BasicFeatures:
    """基础技术指标特征计算器"""

    @staticmethod
    def compute_ema(series: pd.Series, period: int) -> pd.Series:
        """计算指数移动平均（EMA）"""
        return series.ewm(span=period, adjust=False).mean()

    @staticmethod
    def compute_sma(series: pd.Series, period: int) -> pd.Series:
        """计算简单移动平均（SMA）"""
        return series.rolling(window=period).mean()

    @staticmethod
    def compute_rsi(series: pd.Series, period: int = 14) -> pd.Series:
        """计算相对强弱指标（RSI）"""
        delta = series.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()

        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi

    @staticmethod
    def compute_macd(series: pd.Series, fast: int = 12, slow: int = 26, signal: int = 9) -> pd.DataFrame:
        """计算 MACD 指标"""
        ema_fast = BasicFeatures.compute_ema(series, fast)
        ema_slow = BasicFeatures.compute_ema(series, slow)

        macd_line = ema_fast - ema_slow
        signal_line = BasicFeatures.compute_ema(macd_line, signal)
        histogram = macd_line - signal_line

        return pd.DataFrame({
            'macd': macd_line,
            'macd_signal': signal_line,
            'macd_hist': histogram
        })

    @staticmethod
    def compute_atr(high: pd.Series, low: pd.Series, close: pd.Series, period: int = 14) -> pd.Series:
        """计算平均真实波幅（ATR）"""
        # True Range
        tr1 = high - low
        tr2 = abs(high - close.shift())
        tr3 = abs(low - close.shift())

        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)

        # ATR 是 TR 的移动平均
        atr = tr.rolling(window=period).mean()
        return atr

    @staticmethod
    def compute_bollinger_bands(series: pd.Series, period: int = 20, std: int = 2) -> pd.DataFrame:
        """计算布林带"""
        sma = BasicFeatures.compute_sma(series, period)
        rolling_std = series.rolling(window=period).std()

        upper = sma + (rolling_std * std)
        lower = sma - (rolling_std * std)

        return pd.DataFrame({
            'bbands_upper': upper,
            'bbands_middle': sma,
            'bbands_lower': lower,
            'bbands_width': (upper - lower) / sma
        })

    @staticmethod
    def compute_stochastic(high: pd.Series, low: pd.Series, close: pd.Series,
                          k_period: int = 14, d_period: int = 3) -> pd.DataFrame:
        """计算随机震荡指标（Stochastic）"""
        lowest_low = low.rolling(window=k_period).min()
        highest_high = high.rolling(window=k_period).max()

        k = 100 * (close - lowest_low) / (highest_high - lowest_low)
        d = k.rolling(window=d_period).mean()

        return pd.DataFrame({
            'stochastic_k': k,
            'stochastic_d': d
        })

    @staticmethod
    def compute_williams_r(high: pd.Series, low: pd.Series, close: pd.Series, period: int = 14) -> pd.Series:
        """计算威廉指标（Williams %R）"""
        highest_high = high.rolling(window=period).max()
        lowest_low = low.rolling(window=period).min()

        williams_r = -100 * (highest_high - close) / (highest_high - lowest_low)
        return williams_r

    @staticmethod
    def compute_roc(series: pd.Series, period: int = 10) -> pd.Series:
        """计算变化率（ROC - Rate of Change）"""
        roc = ((series - series.shift(period)) / series.shift(period)) * 100
        return roc

    @staticmethod
    def compute_obv(close: pd.Series, volume: pd.Series) -> pd.Series:
        """计算能量潮（OBV - On-Balance Volume）"""
        obv = (np.sign(close.diff()) * volume).fillna(0).cumsum()
        return obv

    @staticmethod
    def compute_realized_volatility(returns: pd.Series, period: int = 20) -> pd.Series:
        """计算已实现波动率"""
        return returns.rolling(window=period).std() * np.sqrt(252)  # 年化

    @staticmethod
    def compute_returns(close: pd.Series, periods: list = [1, 3, 5, 10, 20]) -> pd.DataFrame:
        """计算多期滞后回报"""
        returns_df = pd.DataFrame()

        for period in periods:
            returns_df[f'return_{period}d'] = close.pct_change(period)

        return returns_df

    @staticmethod
    def compute_all_basic_features(df: pd.DataFrame) -> pd.DataFrame:
        """
        计算所有基础特征（30 维）

        Args:
            df: 必须包含 ['open', 'high', 'low', 'close', 'volume'] 列

        Returns:
            添加了基础特征的 DataFrame
        """
        df = df.copy()

        logger.info("计算基础技术指标特征...")

        # 趋势类特征 (10 维)
        df['ema_12'] = BasicFeatures.compute_ema(df['close'], 12)
        df['ema_26'] = BasicFeatures.compute_ema(df['close'], 26)
        df['ema_50'] = BasicFeatures.compute_ema(df['close'], 50)
        df['ema_200'] = BasicFeatures.compute_ema(df['close'], 200)
        df['sma_20'] = BasicFeatures.compute_sma(df['close'], 20)
        df['sma_60'] = BasicFeatures.compute_sma(df['close'], 60)

        df['price_vs_ema200'] = (df['close'] - df['ema_200']) / df['ema_200']
        df['golden_cross'] = (df['ema_50'] > df['ema_200']).astype(int)
        df['death_cross'] = (df['ema_50'] < df['ema_200']).astype(int)
        df['trend_strength'] = (df['ema_12'] - df['ema_200']) / df['ema_200']

        # 动量类特征 (8 维)
        df['rsi_14'] = BasicFeatures.compute_rsi(df['close'], 14)
        macd_df = BasicFeatures.compute_macd(df['close'])
        df = pd.concat([df, macd_df], axis=1)
        df['roc_10'] = BasicFeatures.compute_roc(df['close'], 10)

        stoch_df = BasicFeatures.compute_stochastic(df['high'], df['low'], df['close'])
        df = pd.concat([df, stoch_df], axis=1)

        df['williams_r'] = BasicFeatures.compute_williams_r(df['high'], df['low'], df['close'], 14)

        # 波动类特征 (6 维)
        df['atr_14'] = BasicFeatures.compute_atr(df['high'], df['low'], df['close'], 14)

        bbands_df = BasicFeatures.compute_bollinger_bands(df['close'])
        df = pd.concat([df, bbands_df], axis=1)

        df['return_1d'] = df['close'].pct_change()
        df['realized_volatility_20'] = BasicFeatures.compute_realized_volatility(df['return_1d'], 20)

        # 成交量类特征 (3 维)
        df['volume_sma20'] = BasicFeatures.compute_sma(df['volume'], 20)
        df['volume_ratio'] = df['volume'] / df['volume_sma20']
        df['obv'] = BasicFeatures.compute_obv(df['close'], df['volume'])

        # 滞后回报类特征 (5 维) - return_1d 已计算
        returns_df = BasicFeatures.compute_returns(df['close'], periods=[3, 5, 10, 20])
        df = pd.concat([df, returns_df], axis=1)

        logger.info(f"基础特征计算完成，新增 {len(df.columns) - 6} 个特征")

        return df


def main():
    """测试基础特征计算"""
    # 创建测试数据
    dates = pd.date_range('2023-01-01', periods=300, freq='D')
    np.random.seed(42)

    test_df = pd.DataFrame({
        'date': dates,
        'open': 100 + np.random.randn(300).cumsum(),
        'high': 101 + np.random.randn(300).cumsum(),
        'low': 99 + np.random.randn(300).cumsum(),
        'close': 100 + np.random.randn(300).cumsum(),
        'volume': np.random.randint(1000000, 10000000, 300)
    })

    print("原始数据:")
    print(test_df.head())
    print(f"\n原始列数: {len(test_df.columns)}")

    # 计算基础特征
    result_df = BasicFeatures.compute_all_basic_features(test_df)

    print(f"\n添加特征后列数: {len(result_df.columns)}")
    print("\n新增特征:")
    new_features = [col for col in result_df.columns if col not in test_df.columns]
    for i, feat in enumerate(new_features, 1):
        print(f"{i:2d}. {feat}")

    print(f"\n特征数据预览:")
    print(result_df[new_features].tail(5))

    # 检查缺失值
    print(f"\n缺失值统计:")
    missing_counts = result_df[new_features].isnull().sum()
    print(missing_counts[missing_counts > 0])

    print(f"\n特征完整率: {(1 - result_df[new_features].isnull().sum().sum() / (len(result_df) * len(new_features))):.2%}")


if __name__ == '__main__':
    main()

```

## src/feature_engineering/advanced_features.py

```python
"""
高级特征工程模块 - 实现 40 维高级特征
包括:
1. Fractional Differentiation (6 维)
2. Rolling Statistics (12 维)
3. Cross-Sectional Rank (6 维)
4. Sentiment Momentum (8 维)
5. Adaptive Window Features (3 维)
6. Cross-Asset Features (5 维)
"""

import logging
import numpy as np
import pandas as pd
from typing import Dict, List, Optional

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class AdvancedFeatures:
    """高级特征计算类"""

    @staticmethod
    def fractional_diff(series: pd.Series, d: float = 0.5, threshold: float = 1e-5) -> pd.Series:
        """
        分数阶差分 (Fractional Differentiation)
        保留记忆性的同时实现平稳化

        来源: "Advances in Financial Machine Learning" by Marcos Lopez de Prado

        Args:
            series: 时间序列
            d: 差分阶数 (0 < d < 1)，d=1 为完全差分，d=0.5 为半差分
            threshold: 权重截断阈值

        Returns:
            分数阶差分后的序列
        """
        # 计算权重
        weights = [1.0]
        k = 1

        # 迭代计算权重直到小于阈值
        while True:
            weight = -weights[-1] * (d - k + 1) / k
            if abs(weight) < threshold:
                break
            weights.append(weight)
            k += 1

        weights = np.array(weights[::-1])  # 反转权重

        # 应用卷积
        result = pd.Series(index=series.index, dtype=float)
        for i in range(len(weights) - 1, len(series)):
            result.iloc[i] = np.dot(weights, series.iloc[i - len(weights) + 1:i + 1])

        return result

    @staticmethod
    def compute_fractional_features(df: pd.DataFrame) -> pd.DataFrame:
        """
        计算 Fractional Differentiation 特征 (6 维)

        特征列表:
        1. frac_diff_close_05: 收盘价 d=0.5 分数差分
        2. frac_diff_close_07: 收盘价 d=0.7 分数差分
        3. frac_diff_volume_05: 成交量 d=0.5 分数差分
        4. frac_diff_returns_05: 收益率 d=0.5 分数差分
        5. frac_diff_volatility_05: 波动率 d=0.5 分数差分
        6. frac_diff_sentiment_05: 情感 d=0.5 分数差分

        Args:
            df: 包含 OHLCV 和情感数据的 DataFrame

        Returns:
            添加了 Fractional Differentiation 特征的 DataFrame
        """
        logger.info("计算 Fractional Differentiation 特征...")

        # 1. 收盘价 d=0.5
        df['frac_diff_close_05'] = AdvancedFeatures.fractional_diff(
            df['close'], d=0.5
        )

        # 2. 收盘价 d=0.7 (更强的差分)
        df['frac_diff_close_07'] = AdvancedFeatures.fractional_diff(
            df['close'], d=0.7
        )

        # 3. 成交量 d=0.5
        df['frac_diff_volume_05'] = AdvancedFeatures.fractional_diff(
            df['volume'], d=0.5
        )

        # 4. 收益率 d=0.5
        returns = df['close'].pct_change()
        df['frac_diff_returns_05'] = AdvancedFeatures.fractional_diff(
            returns, d=0.5
        )

        # 5. 波动率 d=0.5 (使用 20 日滚动标准差)
        volatility = df['close'].pct_change().rolling(window=20).std()
        df['frac_diff_volatility_05'] = AdvancedFeatures.fractional_diff(
            volatility, d=0.5
        )

        # 6. 情感 d=0.5
        if 'sentiment_mean' in df.columns:
            df['frac_diff_sentiment_05'] = AdvancedFeatures.fractional_diff(
                df['sentiment_mean'], d=0.5
            )
        else:
            df['frac_diff_sentiment_05'] = 0.0

        logger.info("Fractional Differentiation 特征计算完成 (6 维)")
        return df

    @staticmethod
    def compute_rolling_statistics(df: pd.DataFrame) -> pd.DataFrame:
        """
        计算滚动统计特征 (12 维)

        特征列表:
        1. roll_skew_20: 20 日收益率偏度
        2. roll_kurt_20: 20 日收益率峰度
        3. roll_skew_60: 60 日收益率偏度
        4. roll_kurt_60: 60 日收益率峰度
        5. roll_autocorr_1: 收益率自相关(lag=1)
        6. roll_autocorr_5: 收益率自相关(lag=5)
        7. roll_max_drawdown_20: 20 日最大回撤
        8. roll_max_drawdown_60: 60 日最大回撤
        9. roll_sharpe_20: 20 日 Sharpe 比率
        10. roll_sortino_20: 20 日 Sortino 比率
        11. roll_calmar_60: 60 日 Calmar 比率
        12. roll_tail_ratio_20: 20 日尾部比率 (95th/5th percentile)

        Args:
            df: DataFrame

        Returns:
            添加了滚动统计特征的 DataFrame
        """
        logger.info("计算 Rolling Statistics 特征...")

        returns = df['close'].pct_change()

        # 1-2. 20 日偏度和峰度
        df['roll_skew_20'] = returns.rolling(window=20).skew()
        df['roll_kurt_20'] = returns.rolling(window=20).kurt()

        # 3-4. 60 日偏度和峰度
        df['roll_skew_60'] = returns.rolling(window=60).skew()
        df['roll_kurt_60'] = returns.rolling(window=60).kurt()

        # 5-6. 自相关
        df['roll_autocorr_1'] = returns.rolling(window=20).apply(
            lambda x: x.autocorr(lag=1) if len(x) > 1 else np.nan
        )
        df['roll_autocorr_5'] = returns.rolling(window=20).apply(
            lambda x: x.autocorr(lag=5) if len(x) > 5 else np.nan
        )

        # 7-8. 最大回撤
        def max_drawdown(prices):
            cumulative = (1 + prices).cumprod()
            running_max = cumulative.expanding().max()
            drawdown = (cumulative - running_max) / running_max
            return drawdown.min()

        df['roll_max_drawdown_20'] = returns.rolling(window=20).apply(max_drawdown)
        df['roll_max_drawdown_60'] = returns.rolling(window=60).apply(max_drawdown)

        # 9. Sharpe 比率 (假设无风险利率=0)
        df['roll_sharpe_20'] = (
            returns.rolling(window=20).mean() / returns.rolling(window=20).std()
        ) * np.sqrt(252)  # 年化

        # 10. Sortino 比率 (只考虑下行波动)
        def sortino_ratio(rets):
            downside = rets[rets < 0]
            if len(downside) > 0:
                downside_std = downside.std()
                if downside_std > 0:
                    return (rets.mean() / downside_std) * np.sqrt(252)
            return np.nan

        df['roll_sortino_20'] = returns.rolling(window=20).apply(sortino_ratio)

        # 11. Calmar 比率 (收益率 / 最大回撤)
        df['roll_calmar_60'] = (
            returns.rolling(window=60).mean() * 252 /  # 年化收益
            df['roll_max_drawdown_60'].abs()
        )

        # 12. 尾部比率
        def tail_ratio(rets):
            if len(rets) > 0:
                p95 = np.percentile(rets, 95)
                p05 = np.percentile(rets, 5)
                if p05 != 0:
                    return abs(p95 / p05)
            return np.nan

        df['roll_tail_ratio_20'] = returns.rolling(window=20).apply(tail_ratio)

        logger.info("Rolling Statistics 特征计算完成 (12 维)")
        return df

    @staticmethod
    def compute_cross_sectional_rank(df: pd.DataFrame, all_dfs: Dict[str, pd.DataFrame] = None) -> pd.DataFrame:
        """
        计算横截面排名特征 (6 维)
        相对于所有资产的排名

        特征列表:
        1. cs_rank_return_1d: 1 日收益率横截面排名
        2. cs_rank_return_5d: 5 日收益率横截面排名
        3. cs_rank_volatility: 波动率横截面排名
        4. cs_rank_volume: 成交量横截面排名
        5. cs_rank_rsi: RSI 横截面排名
        6. cs_rank_sentiment: 情感横截面排名

        Args:
            df: 当前资产的 DataFrame
            all_dfs: 所有资产的 DataFrame 字典 {symbol: df}

        Returns:
            添加了横截面排名特征的 DataFrame
        """
        logger.info("计算 Cross-Sectional Rank 特征...")

        if all_dfs is None or len(all_dfs) < 2:
            # 如果没有其他资产数据,设置为中位数 0.5
            logger.warning("没有其他资产数据,横截面排名特征设为 0.5")
            df['cs_rank_return_1d'] = 0.5
            df['cs_rank_return_5d'] = 0.5
            df['cs_rank_volatility'] = 0.5
            df['cs_rank_volume'] = 0.5
            df['cs_rank_rsi'] = 0.5
            df['cs_rank_sentiment'] = 0.5
            return df

        # 为每个日期计算横截面排名
        dates = df['date'].unique()

        for date in dates:
            # 收集所有资产在该日期的数据
            cross_section = []
            for symbol, other_df in all_dfs.items():
                date_data = other_df[other_df['date'] == date]
                if not date_data.empty:
                    cross_section.append({
                        'symbol': symbol,
                        'return_1d': date_data['return_1d'].iloc[0] if 'return_1d' in date_data.columns else np.nan,
                        'return_5d': date_data['return_5d'].iloc[0] if 'return_5d' in date_data.columns else np.nan,
                        'volatility': date_data['volatility_20d'].iloc[0] if 'volatility_20d' in date_data.columns else np.nan,
                        'volume': date_data['volume'].iloc[0],
                        'rsi': date_data['rsi_14'].iloc[0] if 'rsi_14' in date_data.columns else np.nan,
                        'sentiment': date_data['sentiment_mean'].iloc[0] if 'sentiment_mean' in date_data.columns else 0,
                    })

            if len(cross_section) > 1:
                cs_df = pd.DataFrame(cross_section)

                # 计算排名 (百分位数)
                current_symbol = df[df['date'] == date]['symbol'].iloc[0] if 'symbol' in df.columns else None

                if current_symbol:
                    for col, feature in [
                        ('return_1d', 'cs_rank_return_1d'),
                        ('return_5d', 'cs_rank_return_5d'),
                        ('volatility', 'cs_rank_volatility'),
                        ('volume', 'cs_rank_volume'),
                        ('rsi', 'cs_rank_rsi'),
                        ('sentiment', 'cs_rank_sentiment'),
                    ]:
                        if col in cs_df.columns:
                            cs_df[feature] = cs_df[col].rank(pct=True)
                            rank_value = cs_df[cs_df['symbol'] == current_symbol][feature].iloc[0] if not cs_df[cs_df['symbol'] == current_symbol].empty else 0.5
                            df.loc[df['date'] == date, feature] = rank_value

        logger.info("Cross-Sectional Rank 特征计算完成 (6 维)")
        return df

    @staticmethod
    def compute_sentiment_momentum(df: pd.DataFrame) -> pd.DataFrame:
        """
        计算情感动量特征 (8 维)

        特征列表:
        1. sentiment_momentum_5d: 5 日情感动量
        2. sentiment_momentum_20d: 20 日情感动量
        3. sentiment_acceleration: 情感加速度 (动量的变化)
        4. sentiment_divergence: 情感-价格背离 (情感上涨但价格下跌)
        5. sentiment_consistency_5d: 5 日情感一致性 (连续正/负的比例)
        6. sentiment_intensity: 情感强度 (绝对值的均值)
        7. sentiment_volatility_20d: 20 日情感波动率
        8. news_frequency_ma20: 20 日新闻频率移动平均

        Args:
            df: DataFrame

        Returns:
            添加了情感动量特征的 DataFrame
        """
        logger.info("计算 Sentiment Momentum 特征...")

        if 'sentiment_mean' not in df.columns:
            logger.warning("没有情感数据,情感动量特征设为 0")
            for feat in ['sentiment_momentum_5d', 'sentiment_momentum_20d',
                        'sentiment_acceleration', 'sentiment_divergence',
                        'sentiment_consistency_5d', 'sentiment_intensity',
                        'sentiment_volatility_20d', 'news_frequency_ma20']:
                df[feat] = 0.0
            return df

        # 1-2. 情感动量
        df['sentiment_momentum_5d'] = df['sentiment_mean'] - df['sentiment_mean'].shift(5)
        df['sentiment_momentum_20d'] = df['sentiment_mean'] - df['sentiment_mean'].shift(20)

        # 3. 情感加速度
        df['sentiment_acceleration'] = df['sentiment_momentum_5d'] - df['sentiment_momentum_5d'].shift(5)

        # 4. 情感-价格背离
        price_momentum = df['close'].pct_change(5)
        sentiment_momentum = df['sentiment_momentum_5d']
        df['sentiment_divergence'] = (
            ((sentiment_momentum > 0) & (price_momentum < 0)).astype(int) -
            ((sentiment_momentum < 0) & (price_momentum > 0)).astype(int)
        )

        # 5. 情感一致性 (5 日窗口内同向比例)
        def consistency(series):
            if len(series) == 0:
                return 0
            positive = (series > 0).sum()
            negative = (series < 0).sum()
            return max(positive, negative) / len(series)

        df['sentiment_consistency_5d'] = df['sentiment_mean'].rolling(window=5).apply(consistency)

        # 6. 情感强度
        df['sentiment_intensity'] = df['sentiment_mean'].abs().rolling(window=20).mean()

        # 7. 情感波动率
        df['sentiment_volatility_20d'] = df['sentiment_mean'].rolling(window=20).std()

        # 8. 新闻频率移动平均
        if 'news_count' in df.columns:
            df['news_frequency_ma20'] = df['news_count'].rolling(window=20).mean()
        else:
            df['news_frequency_ma20'] = 0.0

        logger.info("Sentiment Momentum 特征计算完成 (8 维)")
        return df

    @staticmethod
    def compute_adaptive_window_features(df: pd.DataFrame) -> pd.DataFrame:
        """
        计算自适应窗口特征 (3 维)
        根据市场波动率动态调整窗口大小

        特征列表:
        1. adaptive_ma: 自适应移动平均 (基于波动率调整窗口)
        2. adaptive_momentum: 自适应动量
        3. adaptive_volatility_ratio: 自适应波动率比率

        Args:
            df: DataFrame

        Returns:
            添加了自适应窗口特征的 DataFrame
        """
        logger.info("计算 Adaptive Window Features...")

        # 计算基准波动率
        returns = df['close'].pct_change()
        baseline_vol = returns.rolling(window=60).std()
        current_vol = returns.rolling(window=20).std()

        # 波动率比率 (当前/基准)
        vol_ratio = current_vol / baseline_vol
        vol_ratio = vol_ratio.fillna(1.0).clip(0.5, 2.0)  # 限制在 0.5-2 倍

        # 1. 自适应移动平均 (高波动时用短窗口,低波动时用长窗口)
        # 窗口: 10 到 50 天
        adaptive_window = (50 - 40 * (vol_ratio - 0.5) / 1.5).clip(10, 50).astype(int)

        df['adaptive_ma'] = np.nan
        for i in range(len(df)):
            if i >= 50:  # 确保有足够数据
                window = adaptive_window.iloc[i]
                df.loc[df.index[i], 'adaptive_ma'] = df['close'].iloc[i-window:i].mean()

        # 2. 自适应动量
        df['adaptive_momentum'] = df['close'] / df['adaptive_ma'] - 1

        # 3. 自适应波动率比率
        df['adaptive_volatility_ratio'] = vol_ratio

        logger.info("Adaptive Window Features 计算完成 (3 维)")
        return df

    @staticmethod
    def compute_cross_asset_features(df: pd.DataFrame, reference_df: pd.DataFrame = None,
                                    reference_symbol: str = 'GSPC.INDX') -> pd.DataFrame:
        """
        计算跨资产特征 (5 维)
        相对于基准资产(如 S&P 500)的特征

        特征列表:
        1. beta_to_market: 相对市场的 Beta (60日)
        2. correlation_to_market: 与市场的相关性 (60日)
        3. relative_strength: 相对强度 (当前资产收益 / 市场收益)
        4. alpha_to_market: 相对市场的 Alpha
        5. tracking_error: 跟踪误差

        Args:
            df: 当前资产的 DataFrame
            reference_df: 基准资产的 DataFrame
            reference_symbol: 基准资产名称

        Returns:
            添加了跨资产特征的 DataFrame
        """
        logger.info("计算 Cross-Asset Features...")

        if reference_df is None or reference_df.empty:
            logger.warning("没有基准资产数据,跨资产特征设为 0")
            df['beta_to_market'] = 0.0
            df['correlation_to_market'] = 0.0
            df['relative_strength'] = 0.0
            df['alpha_to_market'] = 0.0
            df['tracking_error'] = 0.0
            return df

        # 确保日期对齐
        df['date'] = pd.to_datetime(df['date'])
        reference_df['date'] = pd.to_datetime(reference_df['date'])

        # 合并数据
        merged = pd.merge(
            df[['date', 'close']],
            reference_df[['date', 'close']],
            on='date',
            how='left',
            suffixes=('', '_market')
        )

        # 计算收益率
        merged['return'] = merged['close'].pct_change()
        merged['return_market'] = merged['close_market'].pct_change()

        # 1. Beta (60日滚动)
        def rolling_beta(returns, market_returns):
            """计算 Beta"""
            # 去除 NaN
            mask = ~(np.isnan(returns) | np.isnan(market_returns))
            if mask.sum() < 10:
                return np.nan

            returns_clean = returns[mask]
            market_returns_clean = market_returns[mask]

            # 计算协方差和方差
            if len(returns_clean) < 10:
                return np.nan

            covariance = np.cov(returns_clean, market_returns_clean)[0, 1]
            market_variance = np.var(market_returns_clean)

            if market_variance > 0:
                return covariance / market_variance
            return np.nan

        # 计算滚动 Beta
        beta_values = []
        for i in range(len(merged)):
            if i < 60:
                beta_values.append(np.nan)
            else:
                window_returns = merged['return'].iloc[i-60:i].values
                window_market = merged['return_market'].iloc[i-60:i].values
                beta = rolling_beta(window_returns, window_market)
                beta_values.append(beta)

        merged['beta_to_market'] = beta_values

        # 2. 相关性 (60日)
        merged['correlation_to_market'] = merged['return'].rolling(window=60).corr(merged['return_market'])

        # 3. 相对强度 (20日累计收益比)
        merged['relative_strength'] = (
            (1 + merged['return']).rolling(window=20).apply(lambda x: x.prod()) /
            (1 + merged['return_market']).rolling(window=20).apply(lambda x: x.prod())
        )

        # 4. Alpha (收益率 - Beta * 市场收益率)
        merged['alpha_to_market'] = merged['return'] - merged['beta_to_market'] * merged['return_market']

        # 5. 跟踪误差 (60日)
        merged['tracking_error'] = (merged['return'] - merged['return_market']).rolling(window=60).std() * np.sqrt(252)

        # 合并回原 DataFrame
        df['beta_to_market'] = merged['beta_to_market'].values
        df['correlation_to_market'] = merged['correlation_to_market'].values
        df['relative_strength'] = merged['relative_strength'].values
        df['alpha_to_market'] = merged['alpha_to_market'].values
        df['tracking_error'] = merged['tracking_error'].values

        logger.info("Cross-Asset Features 计算完成 (5 维)")
        return df

    @staticmethod
    def compute_all_advanced_features(df: pd.DataFrame, all_dfs: Dict[str, pd.DataFrame] = None,
                                     reference_df: pd.DataFrame = None) -> pd.DataFrame:
        """
        计算所有高级特征 (40 维)

        Args:
            df: 当前资产的 DataFrame
            all_dfs: 所有资产的 DataFrame 字典 (用于横截面特征)
            reference_df: 基准资产的 DataFrame (用于跨资产特征)

        Returns:
            添加了所有高级特征的 DataFrame
        """
        logger.info("开始计算所有高级特征 (40 维)...")

        # 1. Fractional Differentiation (6 维)
        df = AdvancedFeatures.compute_fractional_features(df)

        # 2. Rolling Statistics (12 维)
        df = AdvancedFeatures.compute_rolling_statistics(df)

        # 3. Cross-Sectional Rank (6 维)
        df = AdvancedFeatures.compute_cross_sectional_rank(df, all_dfs)

        # 4. Sentiment Momentum (8 维)
        df = AdvancedFeatures.compute_sentiment_momentum(df)

        # 5. Adaptive Window Features (3 维)
        df = AdvancedFeatures.compute_adaptive_window_features(df)

        # 6. Cross-Asset Features (5 维)
        df = AdvancedFeatures.compute_cross_asset_features(df, reference_df)

        logger.info("所有高级特征计算完成 (40 维) ✓")
        return df


# 测试代码
if __name__ == '__main__':
    # 创建测试数据
    np.random.seed(42)
    dates = pd.date_range('2023-01-01', '2024-01-01', freq='D')

    test_df = pd.DataFrame({
        'date': dates,
        'symbol': 'TEST',
        'open': 100 + np.cumsum(np.random.randn(len(dates))),
        'high': 102 + np.cumsum(np.random.randn(len(dates))),
        'low': 98 + np.cumsum(np.random.randn(len(dates))),
        'close': 100 + np.cumsum(np.random.randn(len(dates))),
        'volume': np.random.randint(1000000, 10000000, len(dates)),
        'sentiment_mean': np.random.randn(len(dates)) * 0.5,
        'news_count': np.random.randint(0, 10, len(dates)),
    })

    # 添加基础特征
    test_df['return_1d'] = test_df['close'].pct_change()
    test_df['return_5d'] = test_df['close'].pct_change(5)
    test_df['volatility_20d'] = test_df['return_1d'].rolling(20).std()
    test_df['rsi_14'] = 50.0

    print("测试高级特征计算...")
    print("=" * 60)

    # 测试 Fractional Differentiation
    test_df = AdvancedFeatures.compute_fractional_features(test_df)
    print("\nFractional Differentiation 特征:")
    print(test_df[['date', 'frac_diff_close_05', 'frac_diff_close_07']].tail())

    # 测试 Rolling Statistics
    test_df = AdvancedFeatures.compute_rolling_statistics(test_df)
    print("\nRolling Statistics 特征:")
    print(test_df[['date', 'roll_skew_20', 'roll_sharpe_20']].tail())

    # 测试 Sentiment Momentum
    test_df = AdvancedFeatures.compute_sentiment_momentum(test_df)
    print("\nSentiment Momentum 特征:")
    print(test_df[['date', 'sentiment_momentum_5d', 'sentiment_divergence']].tail())

    # 测试 Adaptive Window Features
    test_df = AdvancedFeatures.compute_adaptive_window_features(test_df)
    print("\nAdaptive Window Features:")
    print(test_df[['date', 'adaptive_ma', 'adaptive_momentum']].tail())

    print("\n" + "=" * 60)
    print("高级特征测试完成!")
    print(f"总特征数: {len(test_df.columns)} 列")

```

## src/feature_engineering/labeling.py

```python
"""
标签生成模块 - Triple Barrier Labeling
用于监督学习的标签生成

来源: "Advances in Financial Machine Learning" by Marcos Lopez de Prado
"""

import logging
import numpy as np
import pandas as pd
from typing import Optional, Tuple

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class TripleBarrierLabeling:
    """
    三重壁垒标签法 (Triple Barrier Method)

    为每个样本设置三个退出条件:
    1. 上界 (Upper Barrier): 价格上涨达到目标收益 -> 标签 = 1 (做多)
    2. 下界 (Lower Barrier): 价格下跌达到止损 -> 标签 = -1 (做空/止损)
    3. 时间界 (Vertical Barrier): 持有期到期 -> 标签 = 0 或基于收益方向

    优势:
    - 避免固定持有期的偏差
    - 考虑止损和止盈
    - 更符合实际交易逻辑
    """

    @staticmethod
    def apply_triple_barrier(
        prices: pd.Series,
        upper_barrier: float = 0.02,
        lower_barrier: float = -0.02,
        max_holding_period: int = 5,
        stop_loss: Optional[float] = None
    ) -> pd.DataFrame:
        """
        应用三重壁垒标签法

        Args:
            prices: 价格序列 (Series with datetime index)
            upper_barrier: 上界收益率阈值 (默认 2%)
            lower_barrier: 下界收益率阈值 (默认 -2%)
            max_holding_period: 最大持有期 (天数)
            stop_loss: 止损阈值 (可选,如 -1% 止损)

        Returns:
            DataFrame 包含:
                - label: 标签 (1=上涨, -1=下跌, 0=中性)
                - barrier_touched: 触发的壁垒类型 ('upper', 'lower', 'vertical')
                - holding_period: 实际持有期
                - return: 实际收益率
        """
        logger.info("应用 Triple Barrier Labeling...")

        results = []

        for i in range(len(prices) - max_holding_period):
            entry_price = prices.iloc[i]
            entry_date = prices.index[i]

            # 未来价格序列
            future_prices = prices.iloc[i+1:i+1+max_holding_period]

            if len(future_prices) == 0:
                continue

            # 计算收益率
            returns = (future_prices - entry_price) / entry_price

            # 检查壁垒触发
            label = 0
            barrier_touched = 'vertical'
            holding_period = max_holding_period
            actual_return = returns.iloc[-1] if len(returns) > 0 else 0

            # 1. 检查上界
            upper_touch = returns >= upper_barrier
            if upper_touch.any():
                upper_idx = upper_touch.idxmax()
                upper_day = returns.index.get_loc(upper_idx)

                # 2. 检查下界
                lower_touch = returns <= lower_barrier
                if lower_touch.any():
                    lower_idx = lower_touch.idxmax()
                    lower_day = returns.index.get_loc(lower_idx)

                    # 哪个先触发
                    if upper_day <= lower_day:
                        label = 1
                        barrier_touched = 'upper'
                        holding_period = upper_day + 1
                        actual_return = returns.iloc[upper_day]
                    else:
                        label = -1
                        barrier_touched = 'lower'
                        holding_period = lower_day + 1
                        actual_return = returns.iloc[lower_day]
                else:
                    # 只触发上界
                    label = 1
                    barrier_touched = 'upper'
                    holding_period = upper_day + 1
                    actual_return = returns.iloc[upper_day]

            else:
                # 3. 检查下界
                lower_touch = returns <= lower_barrier
                if lower_touch.any():
                    lower_idx = lower_touch.idxmax()
                    lower_day = returns.index.get_loc(lower_idx)
                    label = -1
                    barrier_touched = 'lower'
                    holding_period = lower_day + 1
                    actual_return = returns.iloc[lower_day]
                else:
                    # 到达时间界
                    # 基于最终收益方向判断标签
                    if actual_return > 0:
                        label = 1
                    elif actual_return < 0:
                        label = -1
                    else:
                        label = 0

            # 4. 检查止损 (可选)
            if stop_loss is not None and stop_loss < 0:
                stop_touch = returns <= stop_loss
                if stop_touch.any():
                    stop_idx = stop_touch.idxmax()
                    stop_day = returns.index.get_loc(stop_idx)

                    # 止损优先
                    if stop_day < holding_period:
                        label = -1
                        barrier_touched = 'stop_loss'
                        holding_period = stop_day + 1
                        actual_return = returns.iloc[stop_day]

            results.append({
                'date': entry_date,
                'label': label,
                'barrier_touched': barrier_touched,
                'holding_period': holding_period,
                'return': actual_return,
                'entry_price': entry_price,
            })

        result_df = pd.DataFrame(results)
        result_df.set_index('date', inplace=True)

        # 统计
        label_counts = result_df['label'].value_counts()
        logger.info(f"标签分布: {label_counts.to_dict()}")
        logger.info(f"平均持有期: {result_df['holding_period'].mean():.2f} 天")
        logger.info(f"触发统计: {result_df['barrier_touched'].value_counts().to_dict()}")

        return result_df

    @staticmethod
    def compute_meta_labels(
        predictions: pd.Series,
        actual_returns: pd.Series,
        threshold: float = 0.0
    ) -> pd.Series:
        """
        计算元标签 (Meta-Labeling)

        元标签用于二级模型,判断主模型的预测是否应该被信任

        Args:
            predictions: 主模型的预测 (1=做多, -1=做空)
            actual_returns: 实际收益率
            threshold: 收益率阈值 (默认 0,即盈利=1,亏损=0)

        Returns:
            元标签序列 (1=应该交易, 0=不应该交易)
        """
        logger.info("计算 Meta-Labels...")

        meta_labels = pd.Series(0, index=predictions.index)

        # 做多信号 -> 检查是否盈利
        long_signals = predictions == 1
        meta_labels[long_signals & (actual_returns > threshold)] = 1

        # 做空信号 -> 检查是否盈利
        short_signals = predictions == -1
        meta_labels[short_signals & (actual_returns < -threshold)] = 1

        positive_rate = meta_labels.mean()
        logger.info(f"元标签正样本比例: {positive_rate:.2%}")

        return meta_labels

    @staticmethod
    def compute_sample_weights(
        labels: pd.Series,
        returns: pd.Series,
        decay: float = 0.95
    ) -> pd.Series:
        """
        计算样本权重 (Sample Weights)

        考虑因素:
        1. 时间衰减: 近期样本权重更高
        2. 收益幅度: 收益越大权重越高
        3. 类别平衡: 少数类样本权重更高

        Args:
            labels: 标签序列
            returns: 收益率序列
            decay: 时间衰减系数 (默认 0.95)

        Returns:
            样本权重序列
        """
        logger.info("计算样本权重...")

        weights = pd.Series(1.0, index=labels.index)

        # 1. 时间衰减权重
        n = len(labels)
        time_weights = np.array([decay ** (n - i - 1) for i in range(n)])
        weights *= time_weights

        # 2. 收益幅度权重 (绝对收益越大权重越高)
        return_weights = 1 + np.abs(returns)
        weights *= return_weights

        # 3. 类别平衡权重
        label_counts = labels.value_counts()
        max_count = label_counts.max()

        for label, count in label_counts.items():
            class_weight = max_count / count
            weights[labels == label] *= class_weight

        # 归一化
        weights = weights / weights.sum() * len(weights)

        logger.info(f"权重统计: mean={weights.mean():.4f}, std={weights.std():.4f}, "
                   f"min={weights.min():.4f}, max={weights.max():.4f}")

        return weights

    @staticmethod
    def add_labels_to_dataframe(
        df: pd.DataFrame,
        price_column: str = 'close',
        upper_barrier: float = 0.02,
        lower_barrier: float = -0.02,
        max_holding_period: int = 5,
        stop_loss: Optional[float] = None
    ) -> pd.DataFrame:
        """
        将 Triple Barrier 标签添加到 DataFrame

        Args:
            df: 包含价格数据的 DataFrame
            price_column: 价格列名
            upper_barrier: 上界阈值
            lower_barrier: 下界阈值
            max_holding_period: 最大持有期
            stop_loss: 止损阈值

        Returns:
            添加了标签列的 DataFrame
        """
        logger.info(f"为 DataFrame 添加 Triple Barrier 标签...")

        # 应用三重壁垒
        prices = df.set_index('date')[price_column] if 'date' in df.columns else df[price_column]
        labels_df = TripleBarrierLabeling.apply_triple_barrier(
            prices,
            upper_barrier=upper_barrier,
            lower_barrier=lower_barrier,
            max_holding_period=max_holding_period,
            stop_loss=stop_loss
        )

        # 合并标签
        df = df.set_index('date') if 'date' in df.columns else df
        df = df.join(labels_df[['label', 'barrier_touched', 'holding_period', 'return']], how='left')

        # 填充未标注的行
        df['label'] = df['label'].fillna(0).astype(int)
        df['barrier_touched'] = df['barrier_touched'].fillna('none')
        df['holding_period'] = df['holding_period'].fillna(0).astype(int)
        df['return'] = df['return'].fillna(0)

        # 计算样本权重
        df['sample_weight'] = TripleBarrierLabeling.compute_sample_weights(
            df['label'],
            df['return']
        )

        df = df.reset_index()

        logger.info("标签添加完成 ✓")
        return df


# 测试代码
if __name__ == '__main__':
    # 创建测试数据
    np.random.seed(42)
    dates = pd.date_range('2023-01-01', '2024-01-01', freq='D')

    # 模拟价格序列 (带趋势和噪音)
    trend = np.linspace(100, 120, len(dates))
    noise = np.random.randn(len(dates)) * 2
    prices = pd.Series(trend + noise, index=dates)

    print("测试 Triple Barrier Labeling...")
    print("=" * 60)

    # 应用三重壁垒
    labels_df = TripleBarrierLabeling.apply_triple_barrier(
        prices,
        upper_barrier=0.03,
        lower_barrier=-0.02,
        max_holding_period=5,
        stop_loss=-0.01
    )

    print("\n标签结果:")
    print(labels_df.head(10))

    print("\n标签统计:")
    print(labels_df['label'].value_counts())
    print(f"\n平均持有期: {labels_df['holding_period'].mean():.2f} 天")

    print("\n触发类型统计:")
    print(labels_df['barrier_touched'].value_counts())

    print("\n收益率统计:")
    print(labels_df['return'].describe())

    # 测试添加到 DataFrame
    test_df = pd.DataFrame({
        'date': dates,
        'close': prices.values,
        'volume': np.random.randint(1000000, 10000000, len(dates)),
    })

    test_df = TripleBarrierLabeling.add_labels_to_dataframe(
        test_df,
        upper_barrier=0.03,
        lower_barrier=-0.02,
        max_holding_period=5
    )

    print("\n添加标签后的 DataFrame:")
    print(test_df[['date', 'close', 'label', 'barrier_touched', 'holding_period', 'sample_weight']].head(10))

    print("\n" + "=" * 60)
    print("Triple Barrier Labeling 测试完成!")

```


---

**导出统计**: 4/7 个文件
