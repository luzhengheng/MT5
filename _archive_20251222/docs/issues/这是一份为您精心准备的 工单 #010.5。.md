这是一份为您精心准备的 工单 #010.5。  
这份工单不仅仅是修复 bug，它是将您的策略从“业余验证”推向“专业交易”的关键转折点。特别是其中对 Kelly 公式 的修正，直接关系到策略在实盘中是“盈利”还是“被误杀”。  
请将以下内容直接下发给 Claude。  
🛠️ 工单 #010.5: 策略风控逻辑修正与回测架构升级 (Hotfix)  
优先级: 🔥 Critical (Blocker for #011)  
类型: Bugfix & Infrastructure  
关联: src/strategy/risk_manager.py, bin/run_backtest.py  
预估工时: 4-6 Hours  
1. 背景与目标 (Context)  
在深度审查中发现两个阻碍实盘的关键问题：  
 * Kelly 公式逻辑致命缺陷: 现有的 KellySizer 使用了简化版公式 (P-0.5)/Vol，该公式隐含假设了 1:1 的盈亏比。由于我们的策略是趋势跟踪策略（低胜率 P \approx 0.45，高盈亏比 b \approx 2.0），旧公式计算结果恒为负数，导致系统强制空仓，直接过滤掉了最核心的趋势盈利机会。这是必须立即修复的“隐性亏损”漏洞。  
 * 回测效率瓶颈: Walk-Forward 验证目前是单线程串行执行，随着特征维度的增加，验证耗时过长，严重阻碍了参数迭代。  
本工单目标:  
 * 修正数学模型: 实施适用于非对称赔率的通用 Kelly 公式，确保正确捕捉高赔率机会。  
 * 并行化回测: 利用多核 CPU 将 Walk-Forward 速度提升 4-8 倍。  
 * 统计严谨性: 建立 DSR 试验计数器的持久化机制。  
2. 任务清单 (Tasks)  
✅ Task 1: 修正 Kelly Criterion 逻辑 (Critical Math Fix)  
文件: src/strategy/risk_manager.py  
原逻辑: kelly_percent = (p - 0.5) / normalized_vol (错误假设 b=1)  
新逻辑: 使用通用 Kelly 公式计算最佳风险比例 (Optimal Risk Fraction)。  
数学公式:  
$$ f^* = \frac{p(b+1) - 1}{b} $$  
 * f^*: 凯利风险比例 (Kelly Bet Fraction)  
 * p: 预测胜率 (y_pred_proba)  
 * b: 赔率 (take_profit_ratio)  
代码实现路径:  
 * 获取赔率: 在 KellySizer 中读取策略参数 take_profit_ratio 作为 b。  
 * 计算 f^*: 应用上述公式。  
   * 示例: 若 p=0.45, b=2.0，则 f^* = (0.45 \times 3 - 1)/2 = 0.175 (即建议风险为资金的 17.5%)。  
 * 应用安全边际: risk_pct = f^* * kelly_fraction (如 0.25)。  
 * 计算仓位大小: ⚠️ 注意区分“风险比例”与“持仓比例”。  
   * 单股风险 = ATR * stop_loss_multiplier (或 Price * StopLoss%)  
   * 目标股数 = (Account_Value * risk_pct) / 单股风险  
   * 边界检查: 确保目标股数不超过 max_position_size (如总资金的 20% 或 50%)。  
✅ Task 2: Walk-Forward 回测并行化 (Optimization)  
文件: bin/run_backtest.py  
原逻辑: 循环串行执行 10 次回测，CPU 利用率低。  
新逻辑: 使用 ProcessPoolExecutor 并行分发任务。  
代码实现路径:  
 * 解耦核心函数: 提取顶层函数 run_single_fold(train_data, test_data, params)。  
   * 提示: 在该函数内部实例化 Cerebro。严禁在进程间传递 Cerebro 对象（Pickle 序列化会失败）。  
 * 并行执行:  
   # 伪代码参考  
if __name__ == '__main__':  # Windows 必须  
    with ProcessPoolExecutor() as executor:  
        futures = [executor.submit(run_single_fold, ...) for fold in folds]  
        results = [f.result() for f in futures]  
  
 * 结果合并: 将各子进程返回的 Equity Curve 按时间戳拼接，形成完整的资金曲线。  
✅ Task 3: DSR 试验计数持久化 (Statistics)  
文件: src/reporting/trial_recorder.py (新增), src/reporting/tearsheet.py  
需求:  
DSR (Deflated Sharpe Ratio) 需要知道历史上累计尝试过多少种策略组合 (N)，而不是仅仅当前运行的这一次。  
实现细节:  
 * 创建 data/meta/trial_registry.json，存储 {"global_trial_count": 100}。  
 * 每次运行回测时，读取该值，加 1，写回文件。  
 * 将更新后的 N 传入 DSR 计算函数。  
3. 验收标准 (Definition of Done)  
 * 逻辑验证 (Unit Test):  
   * 构造测试用例：P=0.45, b=2.0。  
   * 判定: 旧代码返回仓位 0，新代码必须返回正数仓位。  
 * 性能验证:  
   * 在 5-Fold Walk-Forward 测试中，并行版耗时应小于串行版的 40%。  
 * 回归测试:  
   * 运行 python bin/run_backtest.py，确保 HTML 报告正常生成，且累计收益率曲线相比修复前应有显著改善（因为捕捉到了更多趋势）。  
💡 给 Claude 的执行提示 (Execution Tips)  
 * 关于 Task 1: 在计算仓位大小时，请务必处理好 b 为 0 或 止损距离为 0 的除零异常。  
 * 关于 Task 2: 如果 df 数据量巨大，传递给子进程可能较慢。对于本项目（中等规模），直接传递 DataFrame 切片是可以接受的。  
 * Git 规范: 请创建分支 fix/issue-010-5-kelly-correction 进行开发。  
指令: Claude，请优先执行 Task 1。这是修正策略盈利能力的“心脏手术”，必须确保数学逻辑 100% 准确。  
